/*-------------------------------------------------------------------------
Coco.ATG -- Attributed Grammar
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   Coco Coco.ATG -namespace at.jku.ssw.Coco
-------------------------------------------------------------------------*/
//$namespace=at.jku.ssw.Coco

COMPILER Coco

	static readonly id : int = 0;
	static readonly str : int = 1;

	public  trace : StringWriter;    // other Coco objects referenced in this ATG
    public  tab : Tab;
    public  dfa : DFA;
    public  pgen : ParserGen;

    private genScanner : bool = false;
    private tokenString : string | null = null;         // used in declarations of literal tokens
    private noString : string = "-none-"; // used in declarations of literal tokens
    private gramName : string | null = null; // grammar name

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
	digit     = "0123456789".
	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.
	stringCh  = ANY - '"' - '\\' - cr - lf.
	charCh    = ANY - '\'' - '\\' - cr - lf.
	printable = '\u0020' .. '\u007e'.
	hex       = "0123456789abcdef".

TOKENS
	ident     = letter { letter | digit }.
	number    = digit { digit }.
	string    = '"' { stringCh | '\\' printable } '"'.
	badString = '"' { stringCh | '\\' printable } (cr | lf).
	char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
	ddtSym    = '$' { digit | letter }.  (. this.tab.SetDDT(this.la.val); .)

	optionSym = '$' letter { letter } '='
	            { digit | letter
	            | '-' | '.' | ':'
	            }.                       (. this.tab.SetOption(this.la.val); .)


COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. let sym : Symbol | null;  let g : Graph, g1 : Graph, g2 : Graph;  let s : CharSet;  let beg : int, line : int; .)
=
  [ // using statements
    ANY                          (. beg =  this.t.pos; line = this.t.line; .)
    { ANY }                      (. this.pgen.usingPos = new Position(beg, this.la.pos, 0, line); .)
  ]

  "COMPILER"                    (. this.genScanner = true;
                                   this.tab.ignored = new CharSet(); .)
  ident                         (. this.gramName = this.t.val;
                                   beg = this.la.pos; line = this.la.line;
                                 .)
  { ANY }                       (. this.tab.semDeclPos = new Position(beg, this.la.pos, 0, line); .)
  [ "IGNORECASE"                (. this.dfa.ignoreCase = true; .) ]   /* pdt */
  [ "TERMINALS" { ident 	(.sym = this.tab.FindSym(this.t.val);
				if (sym != null) this.SemErr("name declared twice");
				else {
					sym = this.tab.NewSym(Node.t, this.t.val, this.t.line, this.t.col);
					sym.tokenKind = Symbol.fixedToken;
				}.)
	} ] /*from cocoxml*/
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<Node.t> }]
  [ "PRAGMAS" { TokenDecl<Node.pr> }]
  { "COMMENTS"                  (. let nested : bool = false; .)
    "FROM" TokenExpr<out g1>
    "TO" TokenExpr<out g2>
    [ "NESTED"                  (. nested = true; .)
    ]                           (. this.dfa.NewComment(g1.l, g2.l, nested); .)
  }
  { "IGNORE" Set<out s>         (. this.tab.ignored.Or(s); .)
  }

  [ "SYMBOLTABLES" { SymboltableDecl } ]

  SYNC
  "PRODUCTIONS"                 (. if (this.genScanner) this.dfa.MakeDeterministic();
                                   this.tab.DeleteNodes();
                                 .)
  { ident                       (. sym = this.tab.FindSym(this.t.val);
                                   let undef : bool = sym == null;
                                   if (undef) sym = this.tab.NewSym(Node.nt, this.t.val, this.t.line, this.t.col);
                                   else {
                                     if (sym.typ == Node.nt) {
                                       if (sym.graph != null) this.SemErr("name declared twice");
                                     } else this.SemErr("this symbol kind not allowed on left side of production");
                                     sym.line = this.t.line;
                                     sym.col = this.t.col;
                                   }
                                   let noAttrs : bool = sym.attrPos == null;
                                   sym.attrPos = null;
                                   let noRet : boolean = sym.retVar==null;
                                   sym.retVar = null;
                                 .)
    [ AttrDecl<sym> ]           (. if (!undef)
                                     if (noAttrs != (sym.attrPos == null)
                                        || noRet != (sym.retVar == null))
                                     this.SemErr("attribute mismatch between declaration and use of this symbol");
                                 .)
    [ SemText<out sym.semPos> ] WEAK
    '='
    Expression<out g>           (. sym.graph = g.l;
                                   this.tab.Finish(g);
                                 .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (this.gramName != this.t.val)
                                     this.SemErr("name does not match grammar name");
                                   this.tab.gramSy = this.tab.FindSym(this.gramName);
                                   if (this.tab.gramSy == null)
                                   this.SemErr("missing production for grammar name");
                                   else {
                                     sym = this.tab.gramSy;
                                     if (sym.attrPos != null)
                                     this.SemErr("grammar symbol must not have attributes");
                                   }
                                   this.tab.noSym = this.tab.NewSym(Node.t, "???", 0, 0); // noSym gets highest number
                                   this.tab.SetupAnys();
                                   this.tab.RenumberPragmas();
                                   if (this.tab.ddt[2]) this.tab.PrintNodes();
                                   if (this.errors.count == 0) {
                                     console.log("checking");
                                     this.tab.CompSymbolSets();
                                     if (this.tab.ddt[7]) this.tab.XRef();
                                     let doGenCode : bool = false;
                                     if(this.tab.ignoreErrors) {
                                       doGenCode = true;
                                       this.tab.GrammarCheckAll();
                                     }
                                     else doGenCode = this.tab.GrammarOk();
                                     if(this.tab.genRREBNF && doGenCode) {
                                        this.pgen.WriteRREBNF();
                                     }
                                     if (doGenCode) {
                                       console.log("parser");
                                       this.pgen.WriteParser();
                                       if (this.genScanner) {
                                         console.log(" + scanner");
                                         this.dfa.WriteScanner();
                                         if (this.tab.ddt[0]) this.dfa.PrintStates();
                                       }
                                       console.log(" generated");
                                       if (this.tab.ddt[8]) this.pgen.WriteStatistics();
                                     }
                                   }
                                   if (this.tab.ddt[6]) this.tab.PrintSymbolTable();
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SymboltableDecl                 (. let st : SymTab; .)
=
  ident                         (. let name : string = this.t.val.toLowerCase();
                                   if (this.tab.FindSymtab(name) != null)
                                   this.SemErr("symbol table name declared twice");
                                   st = new SymTab(name);
                                   this.tab.symtabs.push(st);
                                 .)
  [ "STRICT"                    (. st.strict = true; .)
  ]
  { string                      (. let predef : string = this.tab.Unstring(this.t.val);
                                   if (this.dfa.ignoreCase) predef = predef.toLowerCase();
                                   st.Add(predef);
                                 .)
  }
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. let s : CharSet; .)
=
  ident                         (. let name : string = this.t.val;
                                   let c : CharClass | null = this.tab.FindCharClassByName(name);
                                   if (c != null) this.SemErr("name declared twice");
                                 .)
  '=' Set<out s>                (. if (s.Elements() == 0) this.SemErr("character set must not be empty");
                                   this.tab.NewCharClass(name, s);
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<out s : CharSet>              (. let s2 : CharSet; .)
=
  SimSet<out s>
  { '+' SimSet<out s2>          (. s.Or(s2); .)
  | '-' SimSet<out s2>          (. s.Subtract(s2); .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<out s : CharSet>           (. let n1 : int, n2 : int; .)
=                               (. s = new CharSet(); .)
( ident                         (. let c : CharClass | null = this.tab.FindCharClassByName(this.t.val);
                                   if (c == null) this.SemErr("undefined name"); else s.Or(c.set);
                                 .)
| string                        (. let name : string = this.tab.Unstring(this.t.val);
                                   for (let ch of name)
                                     if (this.dfa.ignoreCase) s.Set(ch.toLowerCase().charCodeAt(0));
                                     else s.Set(ch.charCodeAt(0)); .)
| Char<out n1>                  (. s.Set(n1); .)
  [ ".." Char<out n2>           (. for (let i : int = n1; i <= n2; i++) s.Set(i); .)
  ]
| "ANY"                         (. s = new CharSet(); s.Fill(); .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<out n : int>
=
  char                          (. let name : string = this.tab.Unstring(this.t.val); n = 0;
                                   if (name.length == 1) n = name.charCodeAt(0);
                                   else this.SemErr("unacceptable character value");
                                   if (this.dfa.ignoreCase && n >= 65 /*'A'*/ && n <= 90 /*'Z'*/) n += 32;
                                 .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<typ : int>              (. let s : SymInfo, sym : Symbol, g : Graph;
                                                   let inherits : SymInfo, inheritsSym : Symbol;
						.)
=
  Sym<out s>                      (. sym = this.tab.FindSym(s.name);
                                   if (sym != null) this.SemErr("name declared twice");
                                   else {
                                     sym = this.tab.NewSym(typ, s.name, this.t.line, this.t.col);
                                     sym.tokenKind = Symbol.fixedToken;
                                   }
                                   this.tokenString = null;
                                 .)
  [ ':' Sym<out inherits>
                                (. inheritsSym = this.tab.FindSym(inherits.name);
                                   if (inheritsSym == null) this.SemErr("token '" + sym.name + "' can't inherit from '" + inherits.name + "', name not declared");
                                   else if (inheritsSym == sym) this.SemErr("token '" + sym.name + "' must not inherit from self");
                                   else if (inheritsSym.typ != typ) this.SemErr("token '" + sym.name + "' can't inherit from '" + inheritsSym.name + "'");
                                   else sym.inherits = inheritsSym;
                                 .)
  ]
  SYNC
  ( [
       '@'                                    (. sym.eqAttribute = this.t.val.charCodeAt(0); .)
    ]
    '=' TokenExpr<out g> '.'    (. if (s.kind == Parser.str) this.SemErr("a literal must not be declared with a structure");
    this.tab.Finish(g);
                                   if (this.tokenString == null || this.tokenString == this.noString)
                                   this.dfa.ConvertToStates(g.l, sym);
                                   else { // TokenExpr is a single string
                                     if (this.tab.literals[this.tokenString] != null)
                                     this.SemErr("token string declared twice");
                                     this.tab.literals[this.tokenString] = sym;
                                     this.dfa.MatchLiteral(this.tokenString, sym);
                                   }
                                 .)
  |                             (. if (s.kind == Parser.id) this.genScanner = false;
                                   else this.dfa.MatchLiteral(sym.name, sym);
                                 .)
  )
  [ SemText<out sym.semPos>     (. if (typ == Node.t) this.errors.WarningStr("Warning semantic action on token declarations require a custom Scanner"); .) //(. if (typ != Node.pr) this.SemErr("semantic action not allowed here"); .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<sym : Symbol>            (. let beg : int, col : int, line : int; .)
=
  '<'                           // attributes denoted by < ... >
  ( ('^' | "out")
  ident                       (. sym.retVar = this.t.val; .)
  ":"                         (. beg = this.la.pos; .)
  TypeName                    (. sym.retType = this.scanner.buffer.GetString(beg, this.la.pos); .)
  ( '>'
    | ','                       (. beg = this.la.pos; col = this.la.col; line = this.la.line; .)
      { ANY } '>'               (. if (this.t.pos > beg)
                                     sym.attrPos = new Position(beg, this.t.pos, col, line); .)
    )
  |                             (. beg = this.la.pos; col = this.la.col; line = this.la.line; .)
    [ ANY { ANY } ] '>'         (. if (this.t.pos > beg)
                                     sym.attrPos = new Position(beg, this.t.pos, col, line); .)
  )
|
  "<."                          // attributes denoted by <. ... .>
  ( ('^' | "out")
    ident                       (. sym.retVar = this.t.val; .)
    ":"                         (. beg = this.la.pos; .)
    TypeName                    (. sym.retType = this.scanner.buffer.GetString(beg, this.la.pos); .)
    ( ".>"
    | ','                       (. beg = this.la.pos; col = this.la.col; line = this.la.line; .)
      { ANY } ".>"              (. if (this.t.pos > beg)
                                     sym.attrPos = new Position(beg, this.t.pos, col, line); .)
    )
  |                             (. beg = this.la.pos; col = this.la.col; line = this.la.line; .)
    [ ANY { ANY } ] ".>"        (. if (this.t.pos > beg)
                                     sym.attrPos = new Position(beg, this.t.pos, col, line); .)
  ).

/*------------------------------------------------------------------------------------*/
// type names may contain angle brackets for generics
TypeName
= ident {'.' ident | '[' ']' | '<' TypeName {',' TypeName} '>'}.

/*------------------------------------------------------------------------------------*/

Expression<out g : Graph>         (. let g2 : Graph; .)
=
  Term<out g>                   (. let first : bool = true; .)
  {                             WEAK
    '|'
    Term<out g2>                (. if (first) { this.tab.MakeFirstAlt(g); first = false; }
                                   this.tab.MakeAlternative(g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<out g : Graph>               (. let g2 : Graph, rslv : Node | null = null; g = null; .)
=
( [                             (. rslv = this.tab.NewNodeSym(Node.rslv, null, this.la.line, this.la.col); .)
    Resolver<out rslv.pos>      (. g = new Graph(rslv); .)
  ]
  Factor<out g2>                (. if (rslv != null) this.tab.MakeSequence(g, g2);
                                   else g = g2;
                                 .)
  { Factor<out g2>              (. this.tab.MakeSequence(g, g2); .)
  }
|                               (. g = new Graph(this.tab.NewNodeSym(Node.eps, null, this.t.line, this.t.col)); .)
)                               (. if (g == null) // invalid start of Term
                                     g = new Graph(this.tab.NewNodeSym(Node.eps, null, this.t.line, this.t.col));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Factor<out g : Graph>             (. let s : SymInfo, pos : Position, weak : bool = false;
                                   g = null;
                                 .)
=
( [ "WEAK"                      (. weak = true; .)
  ]
  Sym<out s>                    (. let sym : Symbol | null = this.tab.FindSym(s.name);
                                   if (sym == null && s.kind == Parser.str)
                                     sym = this.tab.literals[s.name] as Symbol;
                                   let undef : bool = sym == null;
                                   if (undef) {
                                     if (s.kind == Parser.id)
                                       sym = this.tab.NewSym(Node.nt, s.name, this.t.line, this.t.col);  // forward nt
                                     else if (this.genScanner) {
                                       sym = this.tab.NewSym(Node.t, s.name, this.t.line, this.t.col);
                                       this.dfa.MatchLiteral(sym.name, sym);
                                     } else {  // undefined string in production
                                        this.SemErr("undefined string in production");
                                       sym = this.tab.eofSy;  // dummy
                                     }
                                   }
                                   let typ : int = sym.typ;
                                   if (typ != Node.t && typ != Node.nt)
                                   this.SemErr("this symbol kind is not allowed in a production");
                                   if (weak)
                                     if (typ == Node.t) typ = Node.wt;
                                     else this.SemErr("only terminals may be weak");
                                   let p : Node = this.tab.NewNodeSym(typ, sym, this.t.line, this.t.col);
                                   g = new Graph(p);
                                 .)
  [ Attribs<p>                  (. if (s.kind != Parser.id) this.SemErr("a literal must not have attributes"); .)
  | ">" ident                   (.
                                   if (typ != Node.t && typ != Node.wt) this.SemErr("only terminals or weak terminals can declare a name in a symbol table");
                                   p.declares = this.t.val.toLowerCase();
                                   if (null == this.tab.FindSymtab(p.declares)) this.SemErr("undeclared symbol table '" + p.declares + "'");
                                 .)
  | ":" ident                   (.
                                   if (typ != Node.t && typ != Node.wt) this.SemErr("only terminals or weak terminals can lookup a name in a symbol table");
                                   p.declared = this.t.val.toLowerCase();
                                   if (null == this.tab.FindSymtab(p.declared)) this.SemErr("undeclared symbol table '" + p.declared + "'");
                                 .)
  ]                             (. if (undef) {
                                     sym.attrPos = p.pos;  // dummy
                                     sym.retVar = p.retVar;  // AH - dummy
                                   } else if ((p.pos == null) != (sym.attrPos == null)
                                             || (p.retVar == null) != (sym.retVar == null))
                                   this.SemErr("attribute mismatch between declaration and use of this symbol");
                                 .)
| '(' Expression<out g> ')'
| '[' Expression<out g> ']'     (. this.tab.MakeOption(g); .)
| '{' Expression<out g> '}'     (. this.tab.MakeIteration(g); .)
| SemText<out pos>              (. let p : Node = this.tab.NewNodeSym(Node.sem, null, this.t.line, this.t.col);
                                   p.pos = pos;
                                   g = new Graph(p);
                                 .)
| "ANY"                         (. let p : Node = this.tab.NewNodeSym(Node.any, null, this.t.line, this.t.col);  // p.set is set in tab.SetupAnys
                                   g = new Graph(p);
                                 .)
| "SYNC"                        (. let p : Node = this.tab.NewNodeSym(Node.sync, null, this.t.line, this.t.col);
                                   g = new Graph(p);
                                 .)
)                               (. if (g == null) // invalid start of Factor
                                     g = new Graph(this.tab.NewNodeSym(Node.eps, null, this.t.line, this.t.col));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Resolver<out pos : Position>
=
  "IF" "("                       (. let beg : int = this.la.pos, col : int = this.la.col, line : int = this.la.line; .)
  Condition                      (. pos = new Position(beg, this.t.pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<out g : Graph>          (. let g2 : Graph; .)
=
  TokenTerm<out g>              (. let first : bool = true; .)
  {                             WEAK
    '|'
    TokenTerm<out g2>           (. if (first) { this.tab.MakeFirstAlt(g); first = false; }
                                   this.tab.MakeAlternative(g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<out g : Graph>          (. let g2 : Graph; .)
=
  TokenFactor<out g>
  { TokenFactor<out g2>         (. this.tab.MakeSequence(g, g2); .)
  }
  [ "CONTEXT"
    '(' TokenExpr<out g2>       (. this.tab.SetContextTrans(g2.l); this.dfa.hasCtxMoves = true;
                                   this.tab.MakeSequence(g, g2); .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<out g : Graph>        (. let s : SymInfo; .)
=
                                (. g = null; .)
( Sym<out s>                    (. if (s.kind == Parser.id) {
                                     let c : CharClass | null = this.tab.FindCharClassByName(this.t.val);
                                     if (c == null) {
                                        this.SemErr("undefined name: " + s.name);
                                       c = this.tab.NewCharClass(s.name, new CharSet());
                                     }
                                     let p : Node = this.tab.NewNodeSym(Node.clas, null, this.t.line, this.t.col); p.val = c.n;
                                     g = new Graph(p);
                                     this.tokenString = this.noString;
                                   } else { // str
                                     g = this.tab.StrToGraph(s.name);
                                     if (this.tokenString == null) this.tokenString = s.name;
                                     else this.tokenString = this.noString;
                                   }
                                 .)
| '(' TokenExpr<out g> ')'
| '[' TokenExpr<out g> ']'      (. this.tab.MakeOption(g); this.tokenString = this.noString; .)
| '{' TokenExpr<out g> '}'      (. this.tab.MakeIteration(g); this.tokenString = this.noString; .)
)                               (. if (g == null) // invalid start of TokenFactor
                                     g = new Graph(this.tab.NewNodeSym(Node.eps, null, this.t.line, this.t.col)); .)
.

/*------------------------------------------------------------------------------------*/

Sym<out s : SymInfo>
=                               (. s = new SymInfo(); s.name = "???"; s.kind = Parser.id; .)
( ident                         (. s.kind = Parser.id; s.name = this.t.val; .)
| (string                       (. s.name = this.t.val; .)
  | char                        (. s.name = "\"" + this.t.val.substr(1, this.t.val.length-2) + "\""; .)
  )                             (. s.kind = Parser.str;
                                   if (this.dfa.ignoreCase) s.name = s.name.toLowerCase();
                                   if (s.name.indexOf(' ') >= 0)
                                   this.SemErr("literal tokens must not contain blanks"); .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<n : Node>                 (. let beg : int, col : int, line : int; .)
=
  '<'                           // attributes denoted by < ... >
  ( ('^' | "out")               (. beg = this.la.pos; .)
    { ANY
    | Bracketed
    | badString                 (. this.SemErr("bad string in attributes"); .)
    }                           (. n.retVar = this.scanner.buffer.GetString(beg, this.la.pos); .)
    ( '>'
    | ','                       (. beg = this.la.pos; col = this.la.col; line = this.la.line; .)
      {  ANY
       | badString              (. this.SemErr("bad string in attributes"); .)
      } '>'                     (. if (this.t.pos > beg) n.pos = new Position(beg, this.t.pos, col, line); .)
    )
  |                             (. beg = this.la.pos; col = this.la.col; line = this.la.line; .)
    [ ( ANY
	  | badString               (. this.SemErr("bad string in attributes"); .)
	  )
      {  ANY
      | badString               (. this.SemErr("bad string in attributes"); .)
      }
    ] '>'                       (. if (this.t.pos > beg) n.pos = new Position(beg, this.t.pos, col, line); .)
  )
|
	"<."                          // attributes denoted by <. ... .>
  ( ('^' | "out")               (. beg = this.la.pos; .)
    { ANY
    | Bracketed
    | badString                 (. this.SemErr("bad string in attributes"); .)
    }                           (. n.retVar = this.scanner.buffer.GetString(beg, this.la.pos); .)
    ( ".>"
    | ','                       (. beg = this.la.pos; col = this.la.col; line = this.la.line; .)
      {  ANY
       | badString              (. this.SemErr("bad string in attributes"); .)
      } ".>"                    (. if (this.t.pos > beg) n.pos = new Position(beg, this.t.pos, col, line); .)
    )
  |                             (. beg = this.la.pos; col = this.la.col; line = this.la.line; .)
    [ ( ANY
	  | badString               (. this.SemErr("bad string in attributes"); .)
	  )
      {  ANY
      | badString               (. this.SemErr("bad string in attributes"); .)
      }
    ] ".>"                      (. if (this.t.pos > beg) n.pos = new Position(beg, this.t.pos, col, line); .)
  )
.

/*------------------------------------------------------------------------------------*/
// skip commas in brackets such as in <out a[i, j], b> or <out a[foo(x, y)], z>
Bracketed
= '(' {Bracketed | ANY} ')' | '[' {Bracketed | ANY} ']'.


/*------------------------------------------------------------------------------------*/

SemText<out pos : Position>
=
  "(."                          (. let beg : int = this.la.pos, col : int = this.la.col, line : int = this.la.line; .)
  { ANY
  | badString                   (. this.SemErr("bad string in semantic action"); .)
  | "(."                        (. this.SemErr("missing end of previous semantic action"); .)
  }
  ".)"                          (. pos = new Position(beg, this.t.pos, col, line); .)
.

END Coco.
