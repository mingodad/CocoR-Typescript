
type int = number;
type char = number;
type bool = boolean;

declare function require(s : string) : {[key: string]: any};
declare var global: {[key: string]: any} | undefined;
declare var std: {[key: string]: any} | undefined;
declare var process: {[key: string]: any} | undefined;
declare var scriptArgs: Array<string> | undefined;
declare var stdScriptArgs: Array<string> | undefined;
declare var stdWriteFile: any | undefined;
declare function stdWriteToStdout(s : string) : void;

if(typeof std == "undefined") {
    (function(){
        var fs = require('fs');
        global.std = {
            "loadFile" : function(fname : string) {
                return fs.readFileSync(fname, 'utf8')
            },
            "open" : function(fname : string, mode : string) {
                var fp = {
                    "fd" : fs.openSync(fname, mode),
                    "close" : function() {
                        fs.closeSync(this.fd);
                    },
                    "write" : function(data : string, fptr : any) {
                        fs.writeSync(this.fd, data);
                    }
    
                };
                return fp
            }
        };
        global.stdWriteFile = function(fname : string, data : string) {
            fs.writeFileSync(fname, data, 'utf8');
        };
        global.stdWriteToStdout = function(data : string) {
            process.stdout.write(data);
        };
        global.stdScriptArgs = process.argv.slice(1);
    })();
} else {
    let qjsThis : {[key : string] : any} = this || {};
    qjsThis.stdScriptArgs = scriptArgs;
    qjsThis.stdWriteFile = function(fname : string, data : string) {
        var fd = std.open(fname, "w");
        fd.puts(data);
        fd.close();
    }
    qjsThis.stdWriteToStdout = function(data : string) {
        std.printf("%s", data);
    }
}

class BitArray {
	_bits : Array<bool>;
	constructor(count : int, defVal : bool =false) {
		this._bits = new Array<bool>(count);
        for(let idx = 0; idx < this._bits.length; ++idx) this._bits[idx] = defVal;
	}

	public SetAll(val : bool) : void {
		for(let idx in this._bits) this._bits[idx] = val;
	}

	public Elements() : int {
		let count : int = 0;
		for(let elm of this._bits) if(elm) ++count;
		return count;
	}

	public checkSameSize(ba : BitArray ) : void {
		if(this._bits.length != ba._bits.length) throw("Bitarray size doesn't match.");
	}

	public Equals(ba : BitArray) : bool {
		if(this._bits.length != ba._bits.length) return false;
		for(let idx in ba._bits) {
			if(ba._bits[idx] != this._bits[idx]) return false;
		}
		return true;
	}

	public Intersect(ba : BitArray) : bool {
		this.checkSameSize(ba);
		for(let idx in ba._bits) if(ba._bits[idx] && this._bits[idx]) return true;
		return false;
	}

	public Get(i : int) : bool { return this._bits[i];}
	public Set(i : int, val : bool) : void { this._bits[i] = val;}
	public Count() : int {return this._bits.length;}

	public Or(ba : BitArray) : BitArray {
		this.checkSameSize(ba);
		for(let idx in ba._bits) {
			this._bits[idx] = ba._bits[idx] || this._bits[idx];
		}
		return this;
	}
	public And(ba : BitArray) : BitArray {
		this.checkSameSize(ba);
		for(let idx in ba._bits) {
			this._bits[idx] = ba._bits[idx] && this._bits[idx];
		}
		return this;
	}

	public Not() : BitArray {
		for(let idx in this._bits) this._bits[idx] = !this._bits[idx];
		return this;
	}
	public Clone() : BitArray {
		let ba : BitArray = new BitArray(0);
		ba._bits = this._bits.slice(0);
		return ba;
	}
}


/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/




class Token {
    public  kind : int = 0;    // token kind
    public  pos : int = 0;     // token position in bytes in the source text (starting at 0)
    public  charPos : int = 0;  // token position in characters in the source text (starting at 0)
    public  col : int = 1;     // token column (starting at 1)
    public  line : int = 1;    // token line (starting at 1)
    public  val : string;  // token value
    public  spaceBefore : string | null = null;  // token spaces
    public  next : Token | null = null;  // ML 2005-03-11 Tokens are kept in linked list
}

//-----------------------------------------------------------------------------------
// StringBuffer
//-----------------------------------------------------------------------------------
class Buffer {

    public static readonly EOF : int = -1; //Char_MaxValue + 1;
    buf : string;         // input buffer
    bufStart : int;       // position of first byte in buffer relative to input stream
    bufLen : int;         // length of buffer
    bufPos : int;         // current position in buffer

    public constructor (s : string) {
        this.buf = s;
        this.bufLen = s.length;
        this.bufStart = this.bufPos = 0;
    }

    public /*virtual*/ Read () : int {
        if (this.bufPos < this.bufLen) {
            return this.buf.charCodeAt(this.bufPos++);
        } else {
            return Buffer.EOF;
        }
    }

    public Peek () : int {
        const curPos : int = this.getPos();
        const ch : int = this.Read();
        this.setPos(curPos);
        return ch;
    }

    // beg .. begin, zero-based, inclusive, in byte
    // end .. end, zero-based, exclusive, in byte
    public GetString (beg : int, end : int) : string {
        return this.buf.slice(beg, end);
    }

    public getPos() : int { return this.bufPos + this.bufStart; }
    public setPos(value : int) : void {
        if (value < 0 || value > this.bufLen) {
            throw "buffer out of bounds access, position: " + value;
        }

        if (value >= this.bufStart && value < this.bufStart + this.bufLen) { // already in buffer
            this.bufPos = value - this.bufStart;
        } else {
            // set the position to the end of the file, Pos will return fileLen.
            this.bufPos = this.bufLen - this.bufStart;
        }
    }

}

//-----------------------------------------------------------------------------------
// Scanner
//-----------------------------------------------------------------------------------
class Scanner {
    static readonly  EOL : char = 10 /*'\n'*/;
    static readonly  eofSym : int = 0; /* pdt */
	static readonly maxT : int = 130;
	static readonly noSym : int = 130;


    public  buffer : Buffer; // scanner buffer

    private t : Token;          // current token
    private ch : int;           // current input character
    private pos : int;          // byte position of current character
    private charPos : int;      // position by unicode characters starting with 0
    private col : int;          // column number of current character
    private line : int;         // line number of current character
    private oldEols : int;      // EOLs that appeared in a comment;
    static  start : Array<int> = []; // maps first token character to start state

    private tokens : Token;     // list of tokens already peeked (first token is a dummy)
    private pt : Token;         // current peek token

    private tval : string; // text of current token
    private tlen : int;         // length of current token

    public parseFileName : string;
    public stateNo : int = 0;	// to user defined states

    private Init0() : void {
        Scanner.start = new Array<int>(128);
        for (let i=0; i<128; ++i) Scanner.start[i] = 0;
		for (let i : int = 65; i <= 90; ++i) Scanner.start[i] = 1;
		for (let i : int = 95; i <= 95; ++i) Scanner.start[i] = 1;
		for (let i : int = 97; i <= 122; ++i) Scanner.start[i] = 1;
		for (let i : int = 170; i <= 170; ++i) Scanner.start[i] = 1;
		for (let i : int = 181; i <= 181; ++i) Scanner.start[i] = 1;
		for (let i : int = 186; i <= 186; ++i) Scanner.start[i] = 1;
		for (let i : int = 192; i <= 214; ++i) Scanner.start[i] = 1;
		for (let i : int = 216; i <= 246; ++i) Scanner.start[i] = 1;
		for (let i : int = 248; i <= 255; ++i) Scanner.start[i] = 1;
		for (let i : int = 49; i <= 57; ++i) Scanner.start[i] = 159;
		Scanner.start[92] = 15; 
		Scanner.start[64] = 160; 
		Scanner.start[48] = 161; 
		Scanner.start[46] = 162; 
		Scanner.start[39] = 44; 
		Scanner.start[34] = 61; 
		Scanner.start[38] = 196; 
		Scanner.start[61] = 163; 
		Scanner.start[58] = 164; 
		Scanner.start[44] = 79; 
		Scanner.start[45] = 197; 
		Scanner.start[47] = 198; 
		Scanner.start[62] = 165; 
		Scanner.start[43] = 166; 
		Scanner.start[123] = 86; 
		Scanner.start[91] = 87; 
		Scanner.start[40] = 88; 
		Scanner.start[60] = 199; 
		Scanner.start[37] = 200; 
		Scanner.start[33] = 167; 
		Scanner.start[124] = 201; 
		Scanner.start[63] = 202; 
		Scanner.start[125] = 95; 
		Scanner.start[93] = 96; 
		Scanner.start[41] = 97; 
		Scanner.start[59] = 98; 
		Scanner.start[126] = 99; 
		Scanner.start[42] = 168; 
		Scanner.start[94] = 203; 
		Scanner.start[35] = 169; 
		Scanner.start[Buffer.EOF] = -1;

	}

    constructor(str : string , fileName : string) {
        this.parseFileName = fileName;
        this.buffer = new Buffer(str); // scanner buffer
        if(Scanner.start.length == 0) this.Init0();
        this.Init();
    }

    private  Init() : void {
        this.pos = -1; this.line = 1; this.col = 0; this.charPos = -1;
        this.oldEols = 0;
        this.NextCh();
        this.pt = this.tokens = new Token();  // first token is a dummy
    }

    private  NextCh() : void {
        if (this.oldEols > 0) { this.ch = Scanner.EOL; this.oldEols--; }
        else {
            this.pos = this.buffer.getPos();
            // buffer reads unicode chars, if UTF8 has been detected
            this.ch = this.buffer.Read(); this.col++; this.charPos++;
            // replace isolated '\r' by '\n' in order to make
            // eol handling uniform across Windows, Unix and Mac
            if (this.ch == 13 /*'\r'*/ && this.buffer.Peek() != Scanner.EOL /*'\n'*/) this.ch = Scanner.EOL;
            if (this.ch == Scanner.EOL) { this.line++; this.col = 0; }
        }

	}

	private AddChChar(ach : int) : void {
		this.tval += String.fromCharCode(ach);
        ++this.tlen;
	}

    private AddCh() : void {
        if (this.ch != Buffer.EOF) {
            this.AddChChar(this.ch);
            this.NextCh();
        }
	}

	private AddStr(s : string) : void{
		this.tval += s;
        this.tlen += s.length;
	}

	private NextChOut() : void {
		this.AddCh();
	}


	Comment0() : bool {
		let level : int = 1, pos0 = this.pos, line0 = this.line, col0 = this.col, charPos0 = this.charPos;
		this.NextCh();
		if ((this.ch as int) == 47 /*'/'*/) {
            this.AddStr("//");
			this.NextCh();
			for(;;) {
				if ((this.ch as int) == 10) {
					level--;
					if (level == 0) { this.oldEols = this.line - line0-1; this.NextChOut(); return true; }
					this.NextChOut();
				} else if (this.ch == Buffer.EOF) return false;
				else this.NextChOut();
			}
		}
		this.buffer.setPos(pos0); this.NextCh(); this.line = line0; this.col = col0; this.charPos = charPos0;
		return false;
	}

	Comment1() : bool {
		let level : int = 1, pos0 = this.pos, line0 = this.line, col0 = this.col, charPos0 = this.charPos;
		this.NextCh();
		if ((this.ch as int) == 42 /*'*'*/) {
            this.AddStr("/*");
			this.NextCh();
			for(;;) {
				if ((this.ch as int) == 42 /*'*'*/) {
					this.NextChOut();
					if ((this.ch as int) == 47 /*'/'*/) {
						level--;
						if (level == 0) { /*this.oldEols = this.line - line0;*/ this.NextChOut(); return true; }
                        this.AddStr("*/");
						this.NextChOut();
					}
                    else this.AddChChar(this.ch);
				} else if (this.ch == Buffer.EOF) return false;
				else this.NextChOut();
			}
		}
		this.buffer.setPos(pos0); this.NextCh(); this.line = line0; this.col = col0; this.charPos = charPos0;
		return false;
	}


    private  CheckLiteral() : void {
		switch (this.t.val) {
			case "abstract": this.t.kind = 6; break;
			case "as": this.t.kind = 7; break;
			case "base": this.t.kind = 8; break;
			case "bool": this.t.kind = 9; break;
			case "break": this.t.kind = 10; break;
			case "byte": this.t.kind = 11; break;
			case "case": this.t.kind = 12; break;
			case "catch": this.t.kind = 13; break;
			case "char": this.t.kind = 14; break;
			case "checked": this.t.kind = 15; break;
			case "class": this.t.kind = 16; break;
			case "const": this.t.kind = 17; break;
			case "continue": this.t.kind = 18; break;
			case "decimal": this.t.kind = 19; break;
			case "default": this.t.kind = 20; break;
			case "delegate": this.t.kind = 21; break;
			case "do": this.t.kind = 22; break;
			case "double": this.t.kind = 23; break;
			case "else": this.t.kind = 24; break;
			case "enum": this.t.kind = 25; break;
			case "event": this.t.kind = 26; break;
			case "explicit": this.t.kind = 27; break;
			case "extern": this.t.kind = 28; break;
			case "false": this.t.kind = 29; break;
			case "finally": this.t.kind = 30; break;
			case "fixed": this.t.kind = 31; break;
			case "float": this.t.kind = 32; break;
			case "for": this.t.kind = 33; break;
			case "foreach": this.t.kind = 34; break;
			case "goto": this.t.kind = 35; break;
			case "if": this.t.kind = 36; break;
			case "implicit": this.t.kind = 37; break;
			case "in": this.t.kind = 38; break;
			case "int": this.t.kind = 39; break;
			case "interface": this.t.kind = 40; break;
			case "internal": this.t.kind = 41; break;
			case "is": this.t.kind = 42; break;
			case "lock": this.t.kind = 43; break;
			case "long": this.t.kind = 44; break;
			case "namespace": this.t.kind = 45; break;
			case "new": this.t.kind = 46; break;
			case "null": this.t.kind = 47; break;
			case "object": this.t.kind = 48; break;
			case "operator": this.t.kind = 49; break;
			case "out": this.t.kind = 50; break;
			case "override": this.t.kind = 51; break;
			case "params": this.t.kind = 52; break;
			case "private": this.t.kind = 53; break;
			case "protected": this.t.kind = 54; break;
			case "public": this.t.kind = 55; break;
			case "readonly": this.t.kind = 56; break;
			case "ref": this.t.kind = 57; break;
			case "return": this.t.kind = 58; break;
			case "sbyte": this.t.kind = 59; break;
			case "sealed": this.t.kind = 60; break;
			case "short": this.t.kind = 61; break;
			case "sizeof": this.t.kind = 62; break;
			case "stackalloc": this.t.kind = 63; break;
			case "static": this.t.kind = 64; break;
			case "string": this.t.kind = 65; break;
			case "struct": this.t.kind = 66; break;
			case "switch": this.t.kind = 67; break;
			case "this": this.t.kind = 68; break;
			case "throw": this.t.kind = 69; break;
			case "true": this.t.kind = 70; break;
			case "try": this.t.kind = 71; break;
			case "typeof": this.t.kind = 72; break;
			case "uint": this.t.kind = 73; break;
			case "ulong": this.t.kind = 74; break;
			case "unchecked": this.t.kind = 75; break;
			case "unsafe": this.t.kind = 76; break;
			case "ushort": this.t.kind = 77; break;
			case "using": this.t.kind = 78; break;
			case "virtual": this.t.kind = 79; break;
			case "void": this.t.kind = 80; break;
			case "volatile": this.t.kind = 81; break;
			case "while": this.t.kind = 82; break;
			case "partial": this.t.kind = 119; break;
			case "yield": this.t.kind = 120; break;
			default: break;
		}
	}

	public NextToken() : Token {
        this.tval = ""; this.tlen = 0;
		for(;;) {
			while (this.ch == 32 /*' '*/ ||
				this.ch >= 9 && this.ch <= 10 || this.ch == 13
			)  this.NextChOut();
			if (this.ch == 47 /*'/'*/ && this.Comment0() ||this.ch == 47 /*'/'*/ && this.Comment1()) continue;
			break;
		}

		let apx : int = 0;
        let recKind : int = Scanner.noSym;
        let recEnd : int = this.pos;
        this.t = new Token();
        this.t.pos = this.pos; this.t.col = this.col; this.t.line = this.line; this.t.charPos = this.charPos;
        if(this.tlen > 0) {this.t.spaceBefore = this.tval; this.tval = ""; this.tlen = 0;}
        let state : int = (this.ch == Buffer.EOF) ? -1 : Scanner.start[this.ch];
        this.tlen = 0; this.tval = ""; this.AddCh();

        let loopState : bool = true;
        while(loopState) {
		switch (state) {
			case -1: { this.t.kind = Scanner.eofSym; loopState = false; break; } // NextCh already done
			case 0: {
				if (recKind != Scanner.noSym) {
					this.tlen = recEnd - this.t.pos;
					this.SetScannerBehindT();
				}
				this.t.kind = recKind; loopState = false; break;
			} // NextCh already done
			case 1:
				recEnd = this.pos; recKind = 1 /* ident */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 90 /*'Z'*/ || this.ch == 95 /*'_'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 122 /*'z'*/ || this.ch == 160 || this.ch == 170 || this.ch == 181 || this.ch == 186 || this.ch >= 192 && this.ch <= 214 || this.ch >= 216 && this.ch <= 246 || this.ch >= 248 && this.ch <= 255) {this.AddCh(); state = 1; break;}
				else if (this.ch == 92) {this.AddCh(); state = 2; break;}
				else {this.t.kind = 1 /* ident */; this.t.val = this.tval; this.CheckLiteral(); return this.t;}
			case 2:
				if (this.ch == 117 /*'u'*/) {this.AddCh(); state = 3; break;}
				else if (this.ch == 85 /*'U'*/) {this.AddCh(); state = 7; break;}
				else {state = 0; break;}
			case 3:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 4; break;}
				else {state = 0; break;}
			case 4:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 5; break;}
				else {state = 0; break;}
			case 5:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 6; break;}
				else {state = 0; break;}
			case 6:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 1; break;}
				else {state = 0; break;}
			case 7:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 8; break;}
				else {state = 0; break;}
			case 8:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 9; break;}
				else {state = 0; break;}
			case 9:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 10; break;}
				else {state = 0; break;}
			case 10:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 11; break;}
				else {state = 0; break;}
			case 11:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 12; break;}
				else {state = 0; break;}
			case 12:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 13; break;}
				else {state = 0; break;}
			case 13:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 14; break;}
				else {state = 0; break;}
			case 14:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 1; break;}
				else {state = 0; break;}
			case 15:
				if (this.ch == 117 /*'u'*/) {this.AddCh(); state = 16; break;}
				else if (this.ch == 85 /*'U'*/) {this.AddCh(); state = 20; break;}
				else {state = 0; break;}
			case 16:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 17; break;}
				else {state = 0; break;}
			case 17:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 18; break;}
				else {state = 0; break;}
			case 18:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 19; break;}
				else {state = 0; break;}
			case 19:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 1; break;}
				else {state = 0; break;}
			case 20:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 21; break;}
				else {state = 0; break;}
			case 21:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 22; break;}
				else {state = 0; break;}
			case 22:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 23; break;}
				else {state = 0; break;}
			case 23:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 24; break;}
				else {state = 0; break;}
			case 24:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 25; break;}
				else {state = 0; break;}
			case 25:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 26; break;}
				else {state = 0; break;}
			case 26:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 27; break;}
				else {state = 0; break;}
			case 27:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 1; break;}
				else {state = 0; break;}
			case 28:
				{
					this.tlen -= apx;
					this.SetScannerBehindT();
					this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 29:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 30; break;}
				else {state = 0; break;}
			case 30:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 30; break;}
				else if (this.ch == 85 /*'U'*/) {this.AddCh(); state = 174; break;}
				else if (this.ch == 117 /*'u'*/) {this.AddCh(); state = 175; break;}
				else if (this.ch == 76 /*'L'*/) {this.AddCh(); state = 176; break;}
				else if (this.ch == 108 /*'l'*/) {this.AddCh(); state = 177; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 31:
				{this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 32:
				recEnd = this.pos; recKind = 3 /* realCon */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 32; break;}
				else if (this.ch == 68 /*'D'*/ || this.ch == 70 /*'F'*/ || this.ch == 77 /*'M'*/ || this.ch == 100 /*'d'*/ || this.ch == 102 /*'f'*/ || this.ch == 109 /*'m'*/) {this.AddCh(); state = 43; break;}
				else if (this.ch == 69 /*'E'*/ || this.ch == 101 /*'e'*/) {this.AddCh(); state = 33; break;}
				else {this.t.kind = 3 /* realCon */; loopState = false; break;}
			case 33:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 35; break;}
				else if (this.ch == 43 /*'+'*/ || this.ch == 45 /*'-'*/) {this.AddCh(); state = 34; break;}
				else {state = 0; break;}
			case 34:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 35; break;}
				else {state = 0; break;}
			case 35:
				recEnd = this.pos; recKind = 3 /* realCon */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 35; break;}
				else if (this.ch == 68 /*'D'*/ || this.ch == 70 /*'F'*/ || this.ch == 77 /*'M'*/ || this.ch == 100 /*'d'*/ || this.ch == 102 /*'f'*/ || this.ch == 109 /*'m'*/) {this.AddCh(); state = 43; break;}
				else {this.t.kind = 3 /* realCon */; loopState = false; break;}
			case 36:
				recEnd = this.pos; recKind = 3 /* realCon */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 36; break;}
				else if (this.ch == 68 /*'D'*/ || this.ch == 70 /*'F'*/ || this.ch == 77 /*'M'*/ || this.ch == 100 /*'d'*/ || this.ch == 102 /*'f'*/ || this.ch == 109 /*'m'*/) {this.AddCh(); state = 43; break;}
				else if (this.ch == 69 /*'E'*/ || this.ch == 101 /*'e'*/) {this.AddCh(); state = 37; break;}
				else {this.t.kind = 3 /* realCon */; loopState = false; break;}
			case 37:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 39; break;}
				else if (this.ch == 43 /*'+'*/ || this.ch == 45 /*'-'*/) {this.AddCh(); state = 38; break;}
				else {state = 0; break;}
			case 38:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 39; break;}
				else {state = 0; break;}
			case 39:
				recEnd = this.pos; recKind = 3 /* realCon */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 39; break;}
				else if (this.ch == 68 /*'D'*/ || this.ch == 70 /*'F'*/ || this.ch == 77 /*'M'*/ || this.ch == 100 /*'d'*/ || this.ch == 102 /*'f'*/ || this.ch == 109 /*'m'*/) {this.AddCh(); state = 43; break;}
				else {this.t.kind = 3 /* realCon */; loopState = false; break;}
			case 40:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 42; break;}
				else if (this.ch == 43 /*'+'*/ || this.ch == 45 /*'-'*/) {this.AddCh(); state = 41; break;}
				else {state = 0; break;}
			case 41:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 42; break;}
				else {state = 0; break;}
			case 42:
				recEnd = this.pos; recKind = 3 /* realCon */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 42; break;}
				else if (this.ch == 68 /*'D'*/ || this.ch == 70 /*'F'*/ || this.ch == 77 /*'M'*/ || this.ch == 100 /*'d'*/ || this.ch == 102 /*'f'*/ || this.ch == 109 /*'m'*/) {this.AddCh(); state = 43; break;}
				else {this.t.kind = 3 /* realCon */; loopState = false; break;}
			case 43:
				{this.t.kind = 3 /* realCon */; loopState = false; break;}
			case 44:
				if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 38 /*'&'*/ || this.ch >= 40 /*'('*/ && this.ch <= 91 /*'['*/ || this.ch >= 93 /*']'*/ && this.ch <= 255) {this.AddCh(); state = 45; break;}
				else if (this.ch == 92) {this.AddCh(); state = 178; break;}
				else {state = 0; break;}
			case 45:
				if (this.ch == 39) {this.AddCh(); state = 60; break;}
				else {state = 0; break;}
			case 46:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 47; break;}
				else {state = 0; break;}
			case 47:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 179; break;}
				else if (this.ch == 39) {this.AddCh(); state = 60; break;}
				else {state = 0; break;}
			case 48:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 49; break;}
				else {state = 0; break;}
			case 49:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 50; break;}
				else {state = 0; break;}
			case 50:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 51; break;}
				else {state = 0; break;}
			case 51:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 45; break;}
				else {state = 0; break;}
			case 52:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 53; break;}
				else {state = 0; break;}
			case 53:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 54; break;}
				else {state = 0; break;}
			case 54:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 55; break;}
				else {state = 0; break;}
			case 55:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 56; break;}
				else {state = 0; break;}
			case 56:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 57; break;}
				else {state = 0; break;}
			case 57:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 58; break;}
				else {state = 0; break;}
			case 58:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 59; break;}
				else {state = 0; break;}
			case 59:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 45; break;}
				else {state = 0; break;}
			case 60:
				{this.t.kind = 4 /* charCon */; loopState = false; break;}
			case 61:
				if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 33 /*'!'*/ || this.ch >= 35 /*'#'*/ && this.ch <= 91 /*'['*/ || this.ch >= 93 /*']'*/ && this.ch <= 255) {this.AddCh(); state = 61; break;}
				else if (this.ch == 34 /*'"'*/) {this.AddCh(); state = 77; break;}
				else if (this.ch == 92) {this.AddCh(); state = 181; break;}
				else {state = 0; break;}
			case 62:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 63; break;}
				else {state = 0; break;}
			case 63:
				if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 33 /*'!'*/ || this.ch >= 35 /*'#'*/ && this.ch <= 47 /*'/'*/ || this.ch >= 58 /*':'*/ && this.ch <= 64 /*'@'*/ || this.ch >= 71 /*'G'*/ && this.ch <= 91 /*'['*/ || this.ch >= 93 /*']'*/ && this.ch <= 96 /*'`'*/ || this.ch >= 103 /*'g'*/ && this.ch <= 255) {this.AddCh(); state = 61; break;}
				else if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 182; break;}
				else if (this.ch == 34 /*'"'*/) {this.AddCh(); state = 77; break;}
				else if (this.ch == 92) {this.AddCh(); state = 181; break;}
				else {state = 0; break;}
			case 64:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 65; break;}
				else {state = 0; break;}
			case 65:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 66; break;}
				else {state = 0; break;}
			case 66:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 67; break;}
				else {state = 0; break;}
			case 67:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 61; break;}
				else {state = 0; break;}
			case 68:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 69; break;}
				else {state = 0; break;}
			case 69:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 70; break;}
				else {state = 0; break;}
			case 70:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 71; break;}
				else {state = 0; break;}
			case 71:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 72; break;}
				else {state = 0; break;}
			case 72:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 73; break;}
				else {state = 0; break;}
			case 73:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 74; break;}
				else {state = 0; break;}
			case 74:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 75; break;}
				else {state = 0; break;}
			case 75:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 61; break;}
				else {state = 0; break;}
			case 76:
				if (this.ch <= 33 /*'!'*/ || this.ch >= 35 /*'#'*/ && this.ch <= 255) {this.AddCh(); state = 76; break;}
				else if (this.ch == 34 /*'"'*/) {this.AddCh(); state = 184; break;}
				else {state = 0; break;}
			case 77:
				{this.t.kind = 5 /* stringCon */; loopState = false; break;}
			case 78:
				{this.t.kind = 84 /* andassgn */; loopState = false; break;}
			case 79:
				{this.t.kind = 87 /* comma */; loopState = false; break;}
			case 80:
				{this.t.kind = 88 /* dec */; loopState = false; break;}
			case 81:
				{this.t.kind = 89 /* divassgn */; loopState = false; break;}
			case 82:
				{this.t.kind = 91 /* dblcolon */; loopState = false; break;}
			case 83:
				{this.t.kind = 92 /* eq */; loopState = false; break;}
			case 84:
				{this.t.kind = 94 /* gteq */; loopState = false; break;}
			case 85:
				{this.t.kind = 95 /* inc */; loopState = false; break;}
			case 86:
				{this.t.kind = 96 /* lbrace */; loopState = false; break;}
			case 87:
				{this.t.kind = 97 /* lbrack */; loopState = false; break;}
			case 88:
				{this.t.kind = 98 /* lpar */; loopState = false; break;}
			case 89:
				{this.t.kind = 99 /* lshassgn */; loopState = false; break;}
			case 90:
				{this.t.kind = 103 /* minusassgn */; loopState = false; break;}
			case 91:
				{this.t.kind = 104 /* modassgn */; loopState = false; break;}
			case 92:
				{this.t.kind = 105 /* neq */; loopState = false; break;}
			case 93:
				{this.t.kind = 107 /* orassgn */; loopState = false; break;}
			case 94:
				{this.t.kind = 109 /* plusassgn */; loopState = false; break;}
			case 95:
				{this.t.kind = 111 /* rbrace */; loopState = false; break;}
			case 96:
				{this.t.kind = 112 /* rbrack */; loopState = false; break;}
			case 97:
				{this.t.kind = 113 /* rpar */; loopState = false; break;}
			case 98:
				{this.t.kind = 114 /* scolon */; loopState = false; break;}
			case 99:
				{this.t.kind = 115 /* tilde */; loopState = false; break;}
			case 100:
				{this.t.kind = 117 /* timesassgn */; loopState = false; break;}
			case 101:
				{this.t.kind = 118 /* _at_orassgn */; loopState = false; break;}
			case 102:
				if (this.ch == 101 /*'e'*/) {this.AddCh(); state = 103; break;}
				else {state = 0; break;}
			case 103:
				if (this.ch == 102 /*'f'*/) {this.AddCh(); state = 104; break;}
				else {state = 0; break;}
			case 104:
				if (this.ch == 105 /*'i'*/) {this.AddCh(); state = 105; break;}
				else {state = 0; break;}
			case 105:
				if (this.ch == 110 /*'n'*/) {this.AddCh(); state = 106; break;}
				else {state = 0; break;}
			case 106:
				if (this.ch == 101 /*'e'*/) {this.AddCh(); state = 107; break;}
				else {state = 0; break;}
			case 107:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 108; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 107; break;}
				else {state = 0; break;}
			case 108:
				{this.t.kind = 131 /* ppDefine */; loopState = false; break;}
			case 109:
				if (this.ch == 110 /*'n'*/) {this.AddCh(); state = 110; break;}
				else {state = 0; break;}
			case 110:
				if (this.ch == 100 /*'d'*/) {this.AddCh(); state = 111; break;}
				else {state = 0; break;}
			case 111:
				if (this.ch == 101 /*'e'*/) {this.AddCh(); state = 112; break;}
				else {state = 0; break;}
			case 112:
				if (this.ch == 102 /*'f'*/) {this.AddCh(); state = 113; break;}
				else {state = 0; break;}
			case 113:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 114; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 113; break;}
				else {state = 0; break;}
			case 114:
				{this.t.kind = 132 /* ppUndef */; loopState = false; break;}
			case 115:
				if (this.ch == 102 /*'f'*/) {this.AddCh(); state = 116; break;}
				else {state = 0; break;}
			case 116:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 117; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 116; break;}
				else {state = 0; break;}
			case 117:
				{this.t.kind = 133 /* ppIf */; loopState = false; break;}
			case 118:
				if (this.ch == 102 /*'f'*/) {this.AddCh(); state = 119; break;}
				else {state = 0; break;}
			case 119:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 120; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 119; break;}
				else {state = 0; break;}
			case 120:
				{this.t.kind = 134 /* ppElif */; loopState = false; break;}
			case 121:
				if (this.ch == 101 /*'e'*/) {this.AddCh(); state = 122; break;}
				else {state = 0; break;}
			case 122:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 123; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 122; break;}
				else {state = 0; break;}
			case 123:
				{this.t.kind = 135 /* ppElse */; loopState = false; break;}
			case 124:
				if (this.ch == 102 /*'f'*/) {this.AddCh(); state = 125; break;}
				else {state = 0; break;}
			case 125:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 126; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 125; break;}
				else {state = 0; break;}
			case 126:
				{this.t.kind = 136 /* ppEndif */; loopState = false; break;}
			case 127:
				if (this.ch == 105 /*'i'*/) {this.AddCh(); state = 128; break;}
				else {state = 0; break;}
			case 128:
				if (this.ch == 110 /*'n'*/) {this.AddCh(); state = 129; break;}
				else {state = 0; break;}
			case 129:
				if (this.ch == 101 /*'e'*/) {this.AddCh(); state = 130; break;}
				else {state = 0; break;}
			case 130:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 131; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 130; break;}
				else {state = 0; break;}
			case 131:
				{this.t.kind = 137 /* ppLine */; loopState = false; break;}
			case 132:
				if (this.ch == 114 /*'r'*/) {this.AddCh(); state = 133; break;}
				else {state = 0; break;}
			case 133:
				if (this.ch == 111 /*'o'*/) {this.AddCh(); state = 134; break;}
				else {state = 0; break;}
			case 134:
				if (this.ch == 114 /*'r'*/) {this.AddCh(); state = 135; break;}
				else {state = 0; break;}
			case 135:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 136; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 135; break;}
				else {state = 0; break;}
			case 136:
				{this.t.kind = 138 /* ppError */; loopState = false; break;}
			case 137:
				if (this.ch == 97 /*'a'*/) {this.AddCh(); state = 138; break;}
				else {state = 0; break;}
			case 138:
				if (this.ch == 114 /*'r'*/) {this.AddCh(); state = 139; break;}
				else {state = 0; break;}
			case 139:
				if (this.ch == 110 /*'n'*/) {this.AddCh(); state = 140; break;}
				else {state = 0; break;}
			case 140:
				if (this.ch == 105 /*'i'*/) {this.AddCh(); state = 141; break;}
				else {state = 0; break;}
			case 141:
				if (this.ch == 110 /*'n'*/) {this.AddCh(); state = 142; break;}
				else {state = 0; break;}
			case 142:
				if (this.ch == 103 /*'g'*/) {this.AddCh(); state = 143; break;}
				else {state = 0; break;}
			case 143:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 144; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 143; break;}
				else {state = 0; break;}
			case 144:
				{this.t.kind = 139 /* ppWarning */; loopState = false; break;}
			case 145:
				if (this.ch == 101 /*'e'*/) {this.AddCh(); state = 146; break;}
				else {state = 0; break;}
			case 146:
				if (this.ch == 103 /*'g'*/) {this.AddCh(); state = 147; break;}
				else {state = 0; break;}
			case 147:
				if (this.ch == 105 /*'i'*/) {this.AddCh(); state = 148; break;}
				else {state = 0; break;}
			case 148:
				if (this.ch == 111 /*'o'*/) {this.AddCh(); state = 149; break;}
				else {state = 0; break;}
			case 149:
				if (this.ch == 110 /*'n'*/) {this.AddCh(); state = 150; break;}
				else {state = 0; break;}
			case 150:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 151; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 150; break;}
				else {state = 0; break;}
			case 151:
				{this.t.kind = 140 /* ppRegion */; loopState = false; break;}
			case 152:
				if (this.ch == 101 /*'e'*/) {this.AddCh(); state = 153; break;}
				else {state = 0; break;}
			case 153:
				if (this.ch == 103 /*'g'*/) {this.AddCh(); state = 154; break;}
				else {state = 0; break;}
			case 154:
				if (this.ch == 105 /*'i'*/) {this.AddCh(); state = 155; break;}
				else {state = 0; break;}
			case 155:
				if (this.ch == 111 /*'o'*/) {this.AddCh(); state = 156; break;}
				else {state = 0; break;}
			case 156:
				if (this.ch == 110 /*'n'*/) {this.AddCh(); state = 157; break;}
				else {state = 0; break;}
			case 157:
				if (this.ch == 10 || this.ch == 13) {this.AddCh(); state = 158; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 255) {this.AddCh(); state = 157; break;}
				else {state = 0; break;}
			case 158:
				{this.t.kind = 141 /* ppEndReg */; loopState = false; break;}
			case 159:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 159; break;}
				else if (this.ch == 85 /*'U'*/) {this.AddCh(); state = 170; break;}
				else if (this.ch == 117 /*'u'*/) {this.AddCh(); state = 171; break;}
				else if (this.ch == 76 /*'L'*/) {this.AddCh(); state = 172; break;}
				else if (this.ch == 108 /*'l'*/) {this.AddCh(); state = 173; break;}
				else if (this.ch == 46 /*'.'*/) {apx++; this.AddCh(); state = 185; break;}
				else if (this.ch == 69 /*'E'*/ || this.ch == 101 /*'e'*/) {this.AddCh(); state = 40; break;}
				else if (this.ch == 68 /*'D'*/ || this.ch == 70 /*'F'*/ || this.ch == 77 /*'M'*/ || this.ch == 100 /*'d'*/ || this.ch == 102 /*'f'*/ || this.ch == 109 /*'m'*/) {this.AddCh(); state = 43; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 160:
				if (this.ch >= 65 /*'A'*/ && this.ch <= 90 /*'Z'*/ || this.ch == 95 /*'_'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 122 /*'z'*/ || this.ch == 170 || this.ch == 181 || this.ch == 186 || this.ch >= 192 && this.ch <= 214 || this.ch >= 216 && this.ch <= 246 || this.ch >= 248 && this.ch <= 255) {this.AddCh(); state = 1; break;}
				else if (this.ch == 92) {this.AddCh(); state = 15; break;}
				else if (this.ch == 34 /*'"'*/) {this.AddCh(); state = 76; break;}
				else {state = 0; break;}
			case 161:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 159; break;}
				else if (this.ch == 85 /*'U'*/) {this.AddCh(); state = 170; break;}
				else if (this.ch == 117 /*'u'*/) {this.AddCh(); state = 171; break;}
				else if (this.ch == 76 /*'L'*/) {this.AddCh(); state = 172; break;}
				else if (this.ch == 108 /*'l'*/) {this.AddCh(); state = 173; break;}
				else if (this.ch == 46 /*'.'*/) {apx++; this.AddCh(); state = 185; break;}
				else if (this.ch == 88 /*'X'*/ || this.ch == 120 /*'x'*/) {this.AddCh(); state = 29; break;}
				else if (this.ch == 69 /*'E'*/ || this.ch == 101 /*'e'*/) {this.AddCh(); state = 40; break;}
				else if (this.ch == 68 /*'D'*/ || this.ch == 70 /*'F'*/ || this.ch == 77 /*'M'*/ || this.ch == 100 /*'d'*/ || this.ch == 102 /*'f'*/ || this.ch == 109 /*'m'*/) {this.AddCh(); state = 43; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 162:
				recEnd = this.pos; recKind = 90 /* dot */;
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {this.AddCh(); state = 32; break;}
				else {this.t.kind = 90 /* dot */; loopState = false; break;}
			case 163:
				recEnd = this.pos; recKind = 85 /* assgn */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 83; break;}
				else {this.t.kind = 85 /* assgn */; loopState = false; break;}
			case 164:
				recEnd = this.pos; recKind = 86 /* colon */;
				if (this.ch == 58 /*':'*/) {this.AddCh(); state = 82; break;}
				else {this.t.kind = 86 /* colon */; loopState = false; break;}
			case 165:
				recEnd = this.pos; recKind = 93 /* gt */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 84; break;}
				else {this.t.kind = 93 /* gt */; loopState = false; break;}
			case 166:
				recEnd = this.pos; recKind = 108 /* plus */;
				if (this.ch == 43 /*'+'*/) {this.AddCh(); state = 85; break;}
				else if (this.ch == 61 /*'='*/) {this.AddCh(); state = 94; break;}
				else {this.t.kind = 108 /* plus */; loopState = false; break;}
			case 167:
				recEnd = this.pos; recKind = 106 /* not */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 92; break;}
				else {this.t.kind = 106 /* not */; loopState = false; break;}
			case 168:
				recEnd = this.pos; recKind = 116 /* times */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 100; break;}
				else {this.t.kind = 116 /* times */; loopState = false; break;}
			case 169:
				if (this.ch == 9 || this.ch >= 11 && this.ch <= 12 || this.ch == 32 /*' '*/) {this.AddCh(); state = 169; break;}
				else if (this.ch == 100 /*'d'*/) {this.AddCh(); state = 102; break;}
				else if (this.ch == 117 /*'u'*/) {this.AddCh(); state = 109; break;}
				else if (this.ch == 105 /*'i'*/) {this.AddCh(); state = 115; break;}
				else if (this.ch == 101 /*'e'*/) {this.AddCh(); state = 187; break;}
				else if (this.ch == 108 /*'l'*/) {this.AddCh(); state = 127; break;}
				else if (this.ch == 119 /*'w'*/) {this.AddCh(); state = 137; break;}
				else if (this.ch == 114 /*'r'*/) {this.AddCh(); state = 145; break;}
				else {state = 0; break;}
			case 170:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch == 76 /*'L'*/ || this.ch == 108 /*'l'*/) {this.AddCh(); state = 31; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 171:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch == 76 /*'L'*/ || this.ch == 108 /*'l'*/) {this.AddCh(); state = 31; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 172:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch == 85 /*'U'*/ || this.ch == 117 /*'u'*/) {this.AddCh(); state = 31; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 173:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch == 85 /*'U'*/ || this.ch == 117 /*'u'*/) {this.AddCh(); state = 31; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 174:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch == 76 /*'L'*/ || this.ch == 108 /*'l'*/) {this.AddCh(); state = 31; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 175:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch == 76 /*'L'*/ || this.ch == 108 /*'l'*/) {this.AddCh(); state = 31; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 176:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch == 85 /*'U'*/ || this.ch == 117 /*'u'*/) {this.AddCh(); state = 31; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 177:
				recEnd = this.pos; recKind = 2 /* intCon */;
				if (this.ch == 85 /*'U'*/ || this.ch == 117 /*'u'*/) {this.AddCh(); state = 31; break;}
				else {this.t.kind = 2 /* intCon */; loopState = false; break;}
			case 178:
				if (this.ch == 34 /*'"'*/ || this.ch == 39 || this.ch == 48 /*'0'*/ || this.ch == 92 || this.ch >= 97 /*'a'*/ && this.ch <= 98 /*'b'*/ || this.ch == 102 /*'f'*/ || this.ch == 110 /*'n'*/ || this.ch == 114 /*'r'*/ || this.ch == 116 /*'t'*/ || this.ch == 118 /*'v'*/) {this.AddCh(); state = 45; break;}
				else if (this.ch == 120 /*'x'*/) {this.AddCh(); state = 46; break;}
				else if (this.ch == 117 /*'u'*/) {this.AddCh(); state = 48; break;}
				else if (this.ch == 85 /*'U'*/) {this.AddCh(); state = 52; break;}
				else {state = 0; break;}
			case 179:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 180; break;}
				else if (this.ch == 39) {this.AddCh(); state = 60; break;}
				else {state = 0; break;}
			case 180:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 45; break;}
				else if (this.ch == 39) {this.AddCh(); state = 60; break;}
				else {state = 0; break;}
			case 181:
				if (this.ch == 34 /*'"'*/ || this.ch == 39 || this.ch == 48 /*'0'*/ || this.ch == 92 || this.ch >= 97 /*'a'*/ && this.ch <= 98 /*'b'*/ || this.ch == 102 /*'f'*/ || this.ch == 110 /*'n'*/ || this.ch == 114 /*'r'*/ || this.ch == 116 /*'t'*/ || this.ch == 118 /*'v'*/) {this.AddCh(); state = 61; break;}
				else if (this.ch == 120 /*'x'*/) {this.AddCh(); state = 62; break;}
				else if (this.ch == 117 /*'u'*/) {this.AddCh(); state = 64; break;}
				else if (this.ch == 85 /*'U'*/) {this.AddCh(); state = 68; break;}
				else {state = 0; break;}
			case 182:
				if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/ || this.ch >= 65 /*'A'*/ && this.ch <= 70 /*'F'*/ || this.ch >= 97 /*'a'*/ && this.ch <= 102 /*'f'*/) {this.AddCh(); state = 183; break;}
				else if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 33 /*'!'*/ || this.ch >= 35 /*'#'*/ && this.ch <= 47 /*'/'*/ || this.ch >= 58 /*':'*/ && this.ch <= 64 /*'@'*/ || this.ch >= 71 /*'G'*/ && this.ch <= 91 /*'['*/ || this.ch >= 93 /*']'*/ && this.ch <= 96 /*'`'*/ || this.ch >= 103 /*'g'*/ && this.ch <= 255) {this.AddCh(); state = 61; break;}
				else if (this.ch == 34 /*'"'*/) {this.AddCh(); state = 77; break;}
				else if (this.ch == 92) {this.AddCh(); state = 181; break;}
				else {state = 0; break;}
			case 183:
				if (this.ch <= 9 || this.ch >= 11 && this.ch <= 12 || this.ch >= 14 && this.ch <= 33 /*'!'*/ || this.ch >= 35 /*'#'*/ && this.ch <= 91 /*'['*/ || this.ch >= 93 /*']'*/ && this.ch <= 255) {this.AddCh(); state = 61; break;}
				else if (this.ch == 34 /*'"'*/) {this.AddCh(); state = 77; break;}
				else if (this.ch == 92) {this.AddCh(); state = 181; break;}
				else {state = 0; break;}
			case 184:
				recEnd = this.pos; recKind = 5 /* stringCon */;
				if (this.ch == 34 /*'"'*/) {this.AddCh(); state = 76; break;}
				else {this.t.kind = 5 /* stringCon */; loopState = false; break;}
			case 185:
				if (this.ch <= 47 /*'/'*/ || this.ch >= 58 /*':'*/ && this.ch <= 255) {apx++; this.AddCh(); state = 28; break;}
				else if (this.ch >= 48 /*'0'*/ && this.ch <= 57 /*'9'*/) {apx = 0; this.AddCh(); state = 36; break;}
				else {state = 0; break;}
			case 186:
				recEnd = this.pos; recKind = 101 /* ltlt */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 89; break;}
				else {this.t.kind = 101 /* ltlt */; loopState = false; break;}
			case 187:
				if (this.ch == 108 /*'l'*/) {this.AddCh(); state = 188; break;}
				else if (this.ch == 110 /*'n'*/) {this.AddCh(); state = 189; break;}
				else if (this.ch == 114 /*'r'*/) {this.AddCh(); state = 132; break;}
				else {state = 0; break;}
			case 188:
				if (this.ch == 105 /*'i'*/) {this.AddCh(); state = 118; break;}
				else if (this.ch == 115 /*'s'*/) {this.AddCh(); state = 121; break;}
				else {state = 0; break;}
			case 189:
				if (this.ch == 100 /*'d'*/) {this.AddCh(); state = 190; break;}
				else {state = 0; break;}
			case 190:
				if (this.ch == 105 /*'i'*/) {this.AddCh(); state = 124; break;}
				else if (this.ch == 114 /*'r'*/) {this.AddCh(); state = 152; break;}
				else {state = 0; break;}
			case 191:
				{this.t.kind = 121 /* "??" */; loopState = false; break;}
			case 192:
				{this.t.kind = 122 /* "||" */; loopState = false; break;}
			case 193:
				{this.t.kind = 123 /* "&&" */; loopState = false; break;}
			case 194:
				{this.t.kind = 126 /* "<=" */; loopState = false; break;}
			case 195:
				{this.t.kind = 129 /* "->" */; loopState = false; break;}
			case 196:
				recEnd = this.pos; recKind = 83 /* and */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 78; break;}
				else if (this.ch == 38 /*'&'*/) {this.AddCh(); state = 193; break;}
				else {this.t.kind = 83 /* and */; loopState = false; break;}
			case 197:
				recEnd = this.pos; recKind = 102 /* minus */;
				if (this.ch == 45 /*'-'*/) {this.AddCh(); state = 80; break;}
				else if (this.ch == 61 /*'='*/) {this.AddCh(); state = 90; break;}
				else if (this.ch == 62 /*'>'*/) {this.AddCh(); state = 195; break;}
				else {this.t.kind = 102 /* minus */; loopState = false; break;}
			case 198:
				recEnd = this.pos; recKind = 127 /* "/" */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 81; break;}
				else {this.t.kind = 127 /* "/" */; loopState = false; break;}
			case 199:
				recEnd = this.pos; recKind = 100 /* lt */;
				if (this.ch == 60 /*'<'*/) {this.AddCh(); state = 186; break;}
				else if (this.ch == 61 /*'='*/) {this.AddCh(); state = 194; break;}
				else {this.t.kind = 100 /* lt */; loopState = false; break;}
			case 200:
				recEnd = this.pos; recKind = 128 /* "%" */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 91; break;}
				else {this.t.kind = 128 /* "%" */; loopState = false; break;}
			case 201:
				recEnd = this.pos; recKind = 124 /* "|" */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 93; break;}
				else if (this.ch == 124 /*'|'*/) {this.AddCh(); state = 192; break;}
				else {this.t.kind = 124 /* "|" */; loopState = false; break;}
			case 202:
				recEnd = this.pos; recKind = 110 /* question */;
				if (this.ch == 63 /*'?'*/) {this.AddCh(); state = 191; break;}
				else {this.t.kind = 110 /* question */; loopState = false; break;}
			case 203:
				recEnd = this.pos; recKind = 125 /* "^" */;
				if (this.ch == 61 /*'='*/) {this.AddCh(); state = 101; break;}
				else {this.t.kind = 125 /* "^" */; loopState = false; break;}

		}
        }
        this.t.val = this.tval;
        return this.t;
    }

    private  SetScannerBehindT() : void {
        this.buffer.setPos(this.t.pos);
        this.NextCh();
        this.line = this.t.line; this.col = this.t.col; this.charPos = this.t.charPos;
        for ( let i : int = 0; i < this.tlen; i++) this.NextCh();
    }

    // get the next token (possibly a token already seen during peeking)
    public  Scan () : Token {
        if (this.tokens.next == null) {
            return this.NextToken();
        } else {
            this.pt = this.tokens = this.tokens.next;
            return this.tokens;
        }
    }

    // peek for the next token, ignore pragmas
    public  Peek () : Token {
        do {
            if (this.pt.next == null) {
                this.pt.next = this.NextToken();
            }
            this.pt = this.pt.next;
        } while (this.pt.kind > Scanner.maxT); // skip pragmas

        return this.pt;
    }

    // make sure that peeking starts at the current scan position
    public  ResetPeek () : void { this.pt = this.tokens; }

} // end Scanner

/*
let scanner : Scanner  = new Scanner(`let a : string = "str";`, "test.txt");
let tok : Token = scanner.Scan()
while(tok.kind != Scanner.eofSym)
{
	console.log(tok);
	tok = scanner.Scan();
}
*/

/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

enum TypeKind {simple, array, pointer, _at_void}

//[Flags]
enum Operator {
  plus   = 0x00000001, minus  = 0x00000002, not    = 0x00000004, tilde  = 0x00000008,
  inc    = 0x00000010, dec    = 0x00000020, _at_true  = 0x00000040, _at_false = 0x00000080,
  times  = 0x00000100, div    = 0x00000200, mod    = 0x00000400, and    = 0x00000800,
  or     = 0x00001000, _at_or    = 0x00002000, lshift = 0x00004000, rshift = 0x00008000,
  eq     = 0x00010000, neq    = 0x00020000, gt     = 0x00040000, lt     = 0x00080000,
  gte    = 0x00100000, lte    = 0x00200000,
  unary  = plus|minus|not|tilde|inc|dec|_at_true|_at_false,
  binary = plus|minus|times|div|mod|and|or|_at_or|lshift|rshift|eq|neq|gt|lt|gte|lte
}

/*------------------------- modifier handling -----------------------------*/

//[Flags]
enum Modifier {
  _at_new      = 0x0001, _at_public = 0x0002, _at_protected= 0x0004, _at_internal = 0x0008,
  _at_private  = 0x0010, _at_unsafe = 0x0020, _at_static   = 0x0040, _at_readonly = 0x0080,
  _at_volatile = 0x0100, _at_virtual= 0x0200, _at_sealed   = 0x0400, _at_override = 0x0800,
  _at_abstract = 0x1000, _at_extern = 0x2000,

  /* sets of modifiers that can be attached to certain program elements    *

   *  e.g., "constants" marks all modifiers that may be used with constants */
  none             = 0x0000,
  classes          = _at_new|_at_public|_at_protected|_at_internal|_at_private|_at_unsafe|_at_abstract|_at_sealed|_at_static,
  constants        = _at_new|_at_public|_at_protected|_at_internal|_at_private,
  fields           = _at_new|_at_public|_at_protected|_at_internal|_at_private|_at_unsafe|_at_static|_at_readonly|_at_volatile,
  propEvntMeths    = _at_new|_at_public|_at_protected|_at_internal|_at_private|_at_unsafe|_at_static|_at_virtual|_at_sealed|_at_override|_at_abstract|_at_extern,
  accessorsPossib1 = _at_private,
  accessorsPossib2 = _at_protected|_at_internal,
  indexers         = _at_new|_at_public|_at_protected|_at_internal|_at_private|_at_unsafe|_at_virtual|_at_sealed|_at_override|_at_abstract|_at_extern,
  operators        = _at_public|_at_unsafe|_at_static|_at_extern,
  operatorsMust    = _at_public|_at_static,
  constructors     = _at_public|_at_protected|_at_internal|_at_private|_at_unsafe|_at_extern,
  staticConstr     = _at_extern|_at_static,
  staticConstrMust = _at_static,
  nonClassTypes    = _at_new|_at_public|_at_protected|_at_internal|_at_private|_at_unsafe,
  destructors      = _at_extern|_at_unsafe,
  all              = 0x3fff
}

class Modifiers {
  private cur : Modifier = Modifier.none;
  private parser : Parser;

   constructor( parser : Parser) {
    this.parser = parser;
  }

  public  Add ( m : Modifier) : void {
    if ((this.cur & m) == 0) this.cur |= m;
    else this.parser.Error("modifier " + m + " already defined");
  }

  public  Add2 ( m : Modifiers) : void { this.Add(m.cur); }

  public  IsNone() : boolean { return this.cur == Modifier.none; }

  public  Check ( allowed : Modifier) : void {
    let wrong : Modifier = this.cur & (allowed ^ Modifier.all);
    if (wrong != Modifier.none)
      this.parser.Error("modifier(s) " + wrong + " not allowed here");
  }

  public  Check2 ( allowEither : Modifier,  allowOr : Modifier) : void {
    let wrong : Modifier = this.cur & ((allowEither|allowOr) ^ Modifier.all);
    if ((allowEither&allowOr) != Modifier.none) {
      this.parser.Error("modifiers providerd must not overlap");
    } else if (wrong != Modifier.none) {
      this.parser.Error("modifier(s) " + wrong + " not allowed here");
    } else if (((this.cur&allowEither) != Modifier.none) && ((this.cur&allowOr) != Modifier.none)) {
      this.parser.Error("modifier(s) may either be " + allowEither + " or " + allowOr);
    }
  }

  public  CheckMust ( mustHave : Modifier) : void {
    let missing : Modifier = (this.cur&mustHave)^mustHave;
    if (missing != Modifier.none) {
      this.parser.Error("modifier(s) " + missing + " must be applied here");
    }
  }

  public  Has ( mod : Modifier) : bool {
    return (this.cur&mod) == mod;
  }
}








class Parser {
	//non terminals
	public static readonly _NT_CS2 : int = 0;
	public static readonly _NT_ExternAliasDirective : int = 1;
	public static readonly _NT_UsingDirective : int = 2;
	public static readonly _NT_GlobalAttributes : int = 3;
	public static readonly _NT_NamespaceMemberDeclaration : int = 4;
	public static readonly _NT_TypeName : int = 5;
	public static readonly _NT_Attributes : int = 6;
	public static readonly _NT_ModifierList : int = 7;
	public static readonly _NT_TypeDeclaration : int = 8;
	public static readonly _NT_TypeParameterList : int = 9;
	public static readonly _NT_ClassBase : int = 10;
	public static readonly _NT_TypeParameterConstraintsClause : int = 11;
	public static readonly _NT_ClassBody : int = 12;
	public static readonly _NT_StructBody : int = 13;
	public static readonly _NT_InterfaceMemberDeclaration : int = 14;
	public static readonly _NT_IntegralType : int = 15;
	public static readonly _NT_EnumBody : int = 16;
	public static readonly _NT_Type : int = 17;
	public static readonly _NT_FormalParameterList : int = 18;
	public static readonly _NT_ClassType : int = 19;
	public static readonly _NT_ClassMemberDeclaration : int = 20;
	public static readonly _NT_StructMemberDeclaration : int = 21;
	public static readonly _NT_EnumMemberDeclaration : int = 22;
	public static readonly _NT_Block : int = 23;
	public static readonly _NT_Expression : int = 24;
	public static readonly _NT_VariableDeclarators : int = 25;
	public static readonly _NT_EventAccessorDeclarations : int = 26;
	public static readonly _NT_Argument : int = 27;
	public static readonly _NT_OverloadableOp : int = 28;
	public static readonly _NT_MemberName : int = 29;
	public static readonly _NT_AccessorDeclarations : int = 30;
	public static readonly _NT_InterfaceAccessors : int = 31;
	public static readonly _NT_LocalVariableDeclaration : int = 32;
	public static readonly _NT_LocalVariableDeclarator : int = 33;
	public static readonly _NT_VariableInitializer : int = 34;
	public static readonly _NT_ArrayInitializer : int = 35;
	public static readonly _NT_Attribute : int = 36;
	public static readonly _NT_Keyword : int = 37;
	public static readonly _NT_AttributeArguments : int = 38;
	public static readonly _NT_PrimitiveType : int = 39;
	public static readonly _NT_PointerOrArray : int = 40;
	public static readonly _NT_ResolvedType : int = 41;
	public static readonly _NT_TypeArgumentList : int = 42;
	public static readonly _NT_InternalClassType : int = 43;
	public static readonly _NT_Statement : int = 44;
	public static readonly _NT_EmbeddedStatement : int = 45;
	public static readonly _NT_StatementExpression : int = 46;
	public static readonly _NT_SwitchSection : int = 47;
	public static readonly _NT_ForInitializer : int = 48;
	public static readonly _NT_ForIterator : int = 49;
	public static readonly _NT_CatchClauses : int = 50;
	public static readonly _NT_ResourceAcquisition : int = 51;
	public static readonly _NT_Unary : int = 52;
	public static readonly _NT_AssignmentOperator : int = 53;
	public static readonly _NT_SwitchLabel : int = 54;
	public static readonly _NT_NullCoalescingExpr : int = 55;
	public static readonly _NT_OrExpr : int = 56;
	public static readonly _NT_AndExpr : int = 57;
	public static readonly _NT_BitOrExpr : int = 58;
	public static readonly _NT_BitXorExpr : int = 59;
	public static readonly _NT_BitAndExpr : int = 60;
	public static readonly _NT_EqlExpr : int = 61;
	public static readonly _NT_RelExpr : int = 62;
	public static readonly _NT_ShiftExpr : int = 63;
	public static readonly _NT_AddExpr : int = 64;
	public static readonly _NT_MulExpr : int = 65;
	public static readonly _NT_Primary : int = 66;
	public static readonly _NT_Literal : int = 67;
	public static readonly _NT_AnonymousMethodParameter : int = 68;
	public static readonly maxNT : int = 68;
	//terminals
	public static readonly _EOF : int = 0;
	public static readonly _ident : int = 1;
	public static readonly _intCon : int = 2;
	public static readonly _realCon : int = 3;
	public static readonly _charCon : int = 4;
	public static readonly _stringCon : int = 5;
	public static readonly _abstract : int = 6;
	public static readonly _as : int = 7;
	public static readonly _base : int = 8;
	public static readonly _bool : int = 9;
	public static readonly _break : int = 10;
	public static readonly _byte : int = 11;
	public static readonly _case : int = 12;
	public static readonly _catch : int = 13;
	public static readonly _char : int = 14;
	public static readonly _checked : int = 15;
	public static readonly _class : int = 16;
	public static readonly _const : int = 17;
	public static readonly _continue : int = 18;
	public static readonly _decimal : int = 19;
	public static readonly _default : int = 20;
	public static readonly _delegate : int = 21;
	public static readonly _do : int = 22;
	public static readonly _double : int = 23;
	public static readonly _else : int = 24;
	public static readonly _enum : int = 25;
	public static readonly _event : int = 26;
	public static readonly _explicit : int = 27;
	public static readonly _extern : int = 28;
	public static readonly _false : int = 29;
	public static readonly _finally : int = 30;
	public static readonly _fixed : int = 31;
	public static readonly _float : int = 32;
	public static readonly _for : int = 33;
	public static readonly _foreach : int = 34;
	public static readonly _goto : int = 35;
	public static readonly _if : int = 36;
	public static readonly _implicit : int = 37;
	public static readonly _in : int = 38;
	public static readonly _int : int = 39;
	public static readonly _interface : int = 40;
	public static readonly _internal : int = 41;
	public static readonly _is : int = 42;
	public static readonly _lock : int = 43;
	public static readonly _long : int = 44;
	public static readonly _namespace : int = 45;
	public static readonly _new : int = 46;
	public static readonly _null : int = 47;
	public static readonly _object : int = 48;
	public static readonly _operator : int = 49;
	public static readonly _xout : int = 50;
	public static readonly _override : int = 51;
	public static readonly _params : int = 52;
	public static readonly _private : int = 53;
	public static readonly _protected : int = 54;
	public static readonly _public : int = 55;
	public static readonly _readonly : int = 56;
	public static readonly _ref : int = 57;
	public static readonly _return : int = 58;
	public static readonly _sbyte : int = 59;
	public static readonly _sealed : int = 60;
	public static readonly _short : int = 61;
	public static readonly _sizeof : int = 62;
	public static readonly _stackalloc : int = 63;
	public static readonly _static : int = 64;
	public static readonly _string : int = 65;
	public static readonly _struct : int = 66;
	public static readonly _switch : int = 67;
	public static readonly _this : int = 68;
	public static readonly _throw : int = 69;
	public static readonly _true : int = 70;
	public static readonly _try : int = 71;
	public static readonly _typeof : int = 72;
	public static readonly _uint : int = 73;
	public static readonly _ulong : int = 74;
	public static readonly _unchecked : int = 75;
	public static readonly _unsafe : int = 76;
	public static readonly _ushort : int = 77;
	public static readonly _usingKW : int = 78;
	public static readonly _virtual : int = 79;
	public static readonly _void : int = 80;
	public static readonly _volatile : int = 81;
	public static readonly _while : int = 82;
	public static readonly _and : int = 83;
	public static readonly _andassgn : int = 84;
	public static readonly _assgn : int = 85;
	public static readonly _colon : int = 86;
	public static readonly _comma : int = 87;
	public static readonly _dec : int = 88;
	public static readonly _divassgn : int = 89;
	public static readonly _dot : int = 90;
	public static readonly _dblcolon : int = 91;
	public static readonly _eq : int = 92;
	public static readonly _gt : int = 93;
	public static readonly _gteq : int = 94;
	public static readonly _inc : int = 95;
	public static readonly _lbrace : int = 96;
	public static readonly _lbrack : int = 97;
	public static readonly _lpar : int = 98;
	public static readonly _lshassgn : int = 99;
	public static readonly _lt : int = 100;
	public static readonly _ltlt : int = 101;
	public static readonly _minus : int = 102;
	public static readonly _minusassgn : int = 103;
	public static readonly _modassgn : int = 104;
	public static readonly _neq : int = 105;
	public static readonly _not : int = 106;
	public static readonly _orassgn : int = 107;
	public static readonly _plus : int = 108;
	public static readonly _plusassgn : int = 109;
	public static readonly _question : int = 110;
	public static readonly _rbrace : int = 111;
	public static readonly _rbrack : int = 112;
	public static readonly _rpar : int = 113;
	public static readonly _scolon : int = 114;
	public static readonly _tilde : int = 115;
	public static readonly _times : int = 116;
	public static readonly _timesassgn : int = 117;
	public static readonly _xorassgn : int = 118;
//	public static readonly _("partial") : int = 119;
//	public static readonly _("yield") : int = 120;
//	public static readonly _("??") : int = 121;
//	public static readonly _("||") : int = 122;
//	public static readonly _("&&") : int = 123;
//	public static readonly _("|") : int = 124;
//	public static readonly _("^") : int = 125;
//	public static readonly _("<=") : int = 126;
//	public static readonly _("/") : int = 127;
//	public static readonly _("%") : int = 128;
//	public static readonly _("->") : int = 129;
//	public static readonly _(???) : int = 130;
	public static readonly maxT : int = 130;
	public static readonly _ppDefine : int = 131;
	public static readonly _ppUndef : int = 132;
	public static readonly _ppIf : int = 133;
	public static readonly _ppElif : int = 134;
	public static readonly _ppElse : int = 135;
	public static readonly _ppEndif : int = 136;
	public static readonly _ppLine : int = 137;
	public static readonly _ppError : int = 138;
	public static readonly _ppWarning : int = 139;
	public static readonly _ppRegion : int = 140;
	public static readonly _ppEndReg : int = 141;

    static readonly  minErrDist : int = 2;

    public  scanner : Scanner;
    public   errors : Errors;

    public  t : Token;    // last recognized token
    public  la : Token;   // lookahead token
    private errDist : int = Parser.minErrDist;

    classMemberNames : {[key: string] : bool} = {};
    classMemberFuncParamNames : {[key: string] : bool} = {};
    
private ccs : Array<string> = new Array<string>();

public  AddConditionalCompilationSymbols(symbols : Array<string>) : void {
  if (symbols != null) {
    for (let i : int=0; i<symbols.length; ++i) {
      symbols[i] = symbols[i].trim();
      if (symbols[i].length > 0 && this.ccs.indexOf(symbols[i])< 0) {
        this.ccs.push(symbols[i]);
      }
    }
  }
}

// returns the end of the whitespaces in the given
// string if whitespaces is true otherwise returns
// the end of the non-whitespaces.
private  EndOf( symbol : string,  start : int,  whitespaces : bool) : int {
  let re = (whitespaces ? /\s/ : /\S/)
  while ((start < symbol.length) && re.test(symbol[start])) {
    ++start;
  }

  return start;
}

// input:        "#" {ws} directive ws {ws} {not-newline} {newline}
// valid input:  "#" {ws} directive ws {ws} {non-ws} {ws} {newline}
// output:       {non-ws}
private  RemPPDirective( symbol : string) : string {
  let start : int = 1;
  let end : int;

  // skip {ws}
  start = this.EndOf(symbol, start, true);
  // skip directive
  start = this.EndOf(symbol, start, false);
  // skip ws {ws}
  start = this.EndOf(symbol, start, true);
  // search end of symbol
  end = this.EndOf(symbol, start, false);

  return symbol.substr(start, end - start);
}

private  AddCCS( symbol : string) : void {
  symbol = this.RemPPDirective(symbol);
  if (this.ccs.indexOf(symbol) < 0) {
    this.ccs.push(symbol);
  }
}

private  RemCCS( symbol : string) : void {
  this.ccs.splice(this.ccs.indexOf(this.RemPPDirective(symbol)));
}

private  IsCCS( symbol : string) : bool {
  return this.ccs.indexOf(this.RemPPDirective(symbol)) >= 0;
}

// search for the correct alternative and enter
// drop everything before the correct alternative
private  IfPragma( symbol : string) : void {
  if (!this.IsCCS(symbol)) {
    let state : int = 0;
    let cur : Token = this.scanner.Scan();

    for (;;) {
      switch (cur.kind) {
        case Parser._ppIf: ++state; break;
        case Parser._ppEndif:
          if (state == 0) { return; }
          --state;
        break;
        case Parser._ppElif:
          if (state == 0 && this.IsCCS(cur.val)) { return; }
        break;
        case Parser._ppElse:
          if (state == 0) { return; }
        break;
        case Parser._EOF: Error("Incomplete file."); return;
        default: break;
      }
      cur = this.scanner.Scan();
    }
  }
}

// drop everything until the end of this if, elif, else directive
private  ElifOrElsePragma() : void {
  let state : int = 0;
  let cur : Token = this.scanner.Scan();

  for (;;) {
    switch (cur.kind) {
      case Parser._ppIf: ++state; break;
      case Parser._ppEndif:
        if (state == 0) { return; }
        --state;
      break;
      default: break;
    }
    cur = this.scanner.Scan();
  }
}

/*----------------------------- token sets -------------------------------*/

static readonly  maxTerminals : int = 160;  // set size

static  NewSet(...values : Array<int> ) : BitArray {
  let a : BitArray = new BitArray(this.maxTerminals);
  for (let x of values) a.Set(x, true);
  return a;
}

static unaryOp : BitArray      = this.NewSet(Parser._plus, Parser._minus, Parser._not, Parser._tilde, Parser._inc, Parser._dec, Parser._true, Parser._false);
static  typeKW : BitArray       = this.NewSet(Parser._char, Parser._bool, Parser._object, Parser._string, Parser._sbyte, Parser._byte, Parser._short,
                 Parser._ushort, Parser._int, Parser._uint, Parser._long, Parser._ulong, Parser._float, Parser._double, Parser._decimal);
static  unaryHead : BitArray    = this.NewSet(Parser._plus, Parser._minus, Parser._not, Parser._tilde, Parser._times, Parser._inc, Parser._dec, Parser._and);
static  assnStartOp : BitArray  = this.NewSet(Parser._plus, Parser._minus, Parser._not, Parser._tilde, Parser._times);
static  castFollower : BitArray = this.NewSet(Parser._tilde, Parser._not, Parser._lpar, Parser._ident,
                 /* literals */
                 Parser._intCon, Parser._realCon, Parser._charCon, Parser._stringCon,
                 /* any keyword expect as and is */
                 Parser._abstract, Parser._base, Parser._bool, Parser._break, Parser._byte, Parser._case, Parser._catch,
                 Parser._char, Parser._checked, Parser._class, Parser._const, Parser._continue, Parser._decimal, Parser._default,
                 Parser._delegate, Parser._do, Parser._double, Parser._else, Parser._enum, Parser._event, Parser._explicit,
                 Parser._extern, Parser._false, Parser._finally, Parser._fixed, Parser._float, Parser._for, Parser._foreach,
                 Parser._goto, Parser._if, Parser._implicit, Parser._in, Parser._int, Parser._interface, Parser._internal,
                 Parser._lock, Parser._long, Parser._namespace, Parser._new, Parser._null, Parser._object, Parser._operator,
                 Parser._xout, Parser._override, Parser._params, Parser._private, Parser._protected, Parser._public,
                 Parser._readonly, Parser._ref, Parser._return, Parser._sbyte, Parser._sealed, Parser._short, Parser._sizeof,
                 Parser._stackalloc, Parser._static, Parser._string, Parser._struct, Parser._switch, Parser._this, Parser._throw,
                 Parser._true, Parser._try, Parser._typeof, Parser._uint, Parser._ulong, Parser._unchecked, Parser._unsafe,
                 Parser._ushort, Parser._usingKW, Parser._virtual, Parser._void, Parser._volatile, Parser._while
                 );
static  typArgLstFol : BitArray = this.NewSet ( Parser._lpar, Parser._rpar, Parser._rbrack, Parser._colon, Parser._scolon, Parser._comma, Parser._dot,
                 Parser._question, Parser._eq, Parser._neq );
static  keyword : BitArray      = this.NewSet(Parser._abstract, Parser._as, Parser._base, Parser._bool, Parser._break, Parser._byte, Parser._case, Parser._catch,
                 Parser._char, Parser._checked, Parser._class, Parser._const, Parser._continue, Parser._decimal, Parser._default,
                 Parser._delegate, Parser._do, Parser._double, Parser._else, Parser._enum, Parser._event, Parser._explicit,
                 Parser._extern, Parser._false, Parser._finally, Parser._fixed, Parser._float, Parser._for, Parser._foreach,
                 Parser._goto, Parser._if, Parser._implicit, Parser._in, Parser._int, Parser._interface, Parser._internal,
                 Parser._is, Parser._lock, Parser._long, Parser._namespace, Parser._new, Parser._null, Parser._object, Parser._operator,
                 Parser._xout, Parser._override, Parser._params, Parser._private, Parser._protected, Parser._public,
                 Parser._readonly, Parser._ref, Parser._return, Parser._sbyte, Parser._sealed, Parser._short, Parser._sizeof,
                 Parser._stackalloc, Parser._static, Parser._string, Parser._struct, Parser._switch, Parser._this, Parser._throw,
                 Parser._true, Parser._try, Parser._typeof, Parser._uint, Parser._ulong, Parser._unchecked, Parser._unsafe,
                 Parser._ushort, Parser._usingKW, Parser._virtual, Parser._void, Parser._volatile, Parser._while);
static  assgnOps : BitArray     = this.NewSet(Parser._assgn, Parser._plusassgn, Parser._minusassgn, Parser._timesassgn, Parser._divassgn,
                 Parser._modassgn, Parser._andassgn, Parser._orassgn, Parser._xorassgn, Parser._lshassgn) /* rshassgn: ">" ">="  no whitespace allowed*/
                 ;

/*---------------------------- auxiliary methods ------------------------*/

public  Error ( s : string) : void {
  if (this.errDist >= Parser.minErrDist) this.errors.SemErrLineColStr(this.la.line, this.la.col, s);
  this.errDist = 0;
}

// Return the n-th token after the current lookahead token
private  Peek ( n : int) : Token {
  this.scanner.ResetPeek();
  let x : Token = this.la;
  while (n > 0) { x = this.scanner.Peek(); n--; }
  return x;
}

// ident "="
private  IsAssignment () : bool {
  return this.la.kind == Parser._ident && this.Peek(1).kind == Parser._assgn;
}

/* True, if the comma is not a trailing one, *

 *  like the last one in: a, b, c,            */
private  NotFinalComma () : bool {
  let peek : int = this.Peek(1).kind;
  return this.la.kind == Parser._comma && peek != Parser._rbrace && peek != Parser._rbrack;
}

/* Checks whether the next sequence of tokens is a qualident *

 *  and returns the qualident string                          *

 *  !!! Proceeds from current peek position !!!               */
/*
private  IsQualident (ref  pt : Token, out  qualident : string) : bool {
    qualident = "";
    if (pt.kind == Parser._ident) {
        qualident = pt.val;
        pt = this.scanner.Peek();
        while (pt.kind == Parser._dot) {
            pt = this.scanner.Peek();
            if (pt.kind != Parser._ident) return false;
            qualident += "." + pt.val;
            pt = this.scanner.Peek();
        }
        return true;
    } else return false;
}
*/
private  IsQualident (pt : Token) : Token | null {
    if (pt.kind == Parser._ident) {
        pt = this.scanner.Peek();
        while (pt.kind == Parser._dot) {
            pt = this.scanner.Peek();
            if (pt.kind != Parser._ident) return null;
            pt = this.scanner.Peek();
        }
        return pt;
    } else return null;
}

private  IsGeneric() : bool {
  this.scanner.ResetPeek();
  let pt : Token | null = this.la;
  pt = this.IsTypeArgumentList(pt);
  if (!pt) {
    return false;
  }
  return Parser.typArgLstFol.Get(pt.kind);
}

private  IsTypeArgumentList(pt : Token) : Token | null {
  let pt2 : Token | null;
  if (pt.kind == Parser._lt) {
    pt = this.scanner.Peek();
    while (true) {
      pt2 = this.IsType(pt);
      if (!pt2) {
        return null;
      }
      pt = pt2;
      if (pt.kind == Parser._gt) {
        // list recognized
        pt = this.scanner.Peek();
        break;
      } else if (pt.kind == Parser._comma) {
        // another argument
        pt = this.scanner.Peek();
      } else {
        // error in type argument list
        return null;
      }
    }
  } else {
    return null;
  }
  return pt;
}

// Type
private  IsType (pt : Token) : Token | null {
  //let dummyId : String;
  let pt2 : Token | null;

  if (Parser.typeKW.Get(pt.kind)) {
    pt = this.scanner.Peek();
  } else if (pt.kind == Parser._void) {
    pt = this.scanner.Peek();
    if (pt.kind != Parser._times) {
      return null;
    }
    pt = this.scanner.Peek();
  } else if (pt.kind == Parser._ident) {
    pt = this.scanner.Peek();
    if (pt.kind == Parser._dblcolon || pt.kind == Parser._dot) {
      // either namespace alias qualifier "::" or first
      // part of the qualident
      pt = this.scanner.Peek();
      //if (!this.IsQualident(ref pt, out dummyId)) {
      pt2 = this.IsQualident(pt);
      if (!pt2) {
        return null;
      }
      pt = pt2;
    }
    if (pt.kind == Parser._lt) {
      pt2 = this.IsTypeArgumentList(pt);
      if(!pt2) {
        return null;
      }
      pt = pt2;
    }
  } else {
    return null;
  }
  if (pt.kind == Parser._question) {
    pt = this.scanner.Peek();
  }
  return this.SkipPointerOrDims(pt);
}

// Type ident
// (Type can be void*)
private  IsLocalVarDecl() : bool {
  let pt : Token | null = this.la;
  this.scanner.ResetPeek();
  pt = this.IsType(pt);
  return pt != null && pt.kind == Parser._ident;
}

// "[" ("," | "]")
private  IsDims () : bool {
  let peek : int = this.Peek(1).kind;
  return this.la.kind == Parser._lbrack && (peek == Parser._comma || peek == Parser._rbrack);
}

// "*" | "[" ("," | "]")
private  IsPointerOrDims () : bool {
  return this.la.kind == Parser._times || this.IsDims();
}

/* skip: { "[" { "," } "]" | "*"" }             */
/* !!! Proceeds from current peek position !!! */
private  SkipPointerOrDims (pt : Token) : Token | null {
  for (;;) {
    if (pt.kind == Parser._lbrack) {
      do pt = this.scanner.Peek();
      while (pt.kind == Parser._comma);
      if (pt.kind != Parser._rbrack) return null;
    } else if (pt.kind != Parser._times) break;
    pt = this.scanner.Peek();
  }
  return pt;
}

// Is attribute target specifier
// (ident | keyword) ":"
private  IsAttrTargSpec () : bool {
  return (this.la.kind == Parser._ident || Parser.keyword.Get(this.la.kind)) && this.Peek(1).kind == Parser._colon;
}

// ident ("," | "=" | ";")
private  IsFieldDecl () : bool {
  let peek : int = this.Peek(1).kind;
  return this.la.kind == Parser._ident &&
         (peek == Parser._comma || peek == Parser._assgn || peek == Parser._scolon);
}

private  IsTypeCast () : bool {
  if (this.la.kind != Parser._lpar) { return false; }
  if (this.IsSimpleTypeCast()) { return true; }
  return this.GuessTypeCast();
}

// "(" typeKW ")"
private  IsSimpleTypeCast () : bool {
    // assert: la.kind == _lpar
    this.scanner.ResetPeek();
    let pt1 : Token = this.scanner.Peek();
    let pt2 : Token = this.scanner.Peek();
    return Parser.typeKW[pt1.kind] &&
            (pt2.kind == Parser._rpar ||
            (pt2.kind == Parser._question && this.scanner.Peek().kind == Parser._rpar));
}

// "(" Type ")" castFollower
private  GuessTypeCast () : bool {
  // assert: la.kind == _lpar
  this.scanner.ResetPeek();
  let pt : Token | null = this.scanner.Peek();
  pt = this.IsType(pt);
  if (!pt) {
    return false;
  }
  if (pt.kind != Parser._rpar) {
    return false;
  }
  pt = this.scanner.Peek();
  return Parser.castFollower.Get(pt.kind);
}

// "[" "assembly"
private  IsGlobalAttrTarget () : bool {
  let pt : Token = this.Peek(1);
  return this.la.kind == Parser._lbrack && pt.kind == Parser._ident && ("assembly" == pt.val) || ("module" == pt.val);
}

// "extern" "alias"
// where alias is an identifier, no keyword
private  IsExternAliasDirective () : bool {
  return this.la.kind == Parser._extern && "alias" == this.Peek(1).val;
}

// true: anyToken"<"
// no whitespace between the token and the "<" allowed
// anything else will return false.
private  IsLtNoWs() : bool {
  return (this.la.kind == Parser._lt) && ((this.t.pos + this.t.val.length) == this.la.pos);
}

private  IsNoSwitchLabelOrRBrace() : bool {
  return (this.la.kind != Parser._case && this.la.kind != Parser._default && this.la.kind != Parser._rbrace) ||
         (this.la.kind == Parser._default && this.Peek(1).kind != Parser._colon);
}

private  IsShift() : bool {
  let pt : Token = this.Peek(1);
  return (this.la.kind == Parser._ltlt) ||
         ( this.la.kind == Parser._gt &&
           pt.kind == Parser._gt &&
           (this.la.pos + this.la.val.length == pt.pos)
         );
}

// true: TypeArgumentList followed by anything but "("
private  IsPartOfMemberName() : bool {
  this.scanner.ResetPeek();
  let pt : Token | null = this.la;
  pt = this.IsTypeArgumentList(pt);
  if (!pt) {
    return false;
  }
  return pt.kind != Parser._lpar;
}



public  symbols2( name : string) : Symboltable | null {
	return null;
}

private  writeOutStr( s : string) : void {
	stdWriteToStdout(s);
}

private  writeOut() : void {
	if(this.t.spaceBefore != null) this.writeOutStr(this.t.spaceBefore);
	this.writeOutStr(this.t.val);
}

private  setTVal( s : string) : void {
	this.writeOut();
	this.t.val = s;
	this.t.spaceBefore = null;
}


/*------------------------------------------------------------------------*
 *----- SCANNER DESCRIPTION ----------------------------------------------*
 *------------------------------------------------------------------------*/

	public symbols(name : string) : Symboltable | null {
		return null;
	}


    constructor( scanner : Scanner) {
        this.scanner = scanner;
        this.errors = new Errors(this.scanner.parseFileName);

	}

    private  SynErr ( n : int) : void {
        if (this.errDist >= Parser.minErrDist) this.errors.SynErr(this.la.line, this.la.col, n);
        this.errDist = 0;
    }

    public  SemErr ( msg : string) : void {
        if (this.errDist >= Parser.minErrDist) this.errors.SemErrLineColStr(this.t.line, this.t.col, msg);
        this.errDist = 0;
    }

    private  Get () : void {
        for (;;) {
            //console.log(this.t, this.la);
            if(this.t != null) this.writeOut();
            this.t = this.la;
            this.la = this.scanner.Scan();
            if (this.la.kind <= Parser.maxT) { ++this.errDist; break; }
			if (this.la.kind == Parser._ppDefine) {
				this.AddCCS(this.la.val); 
			}
			if (this.la.kind == Parser._ppUndef) {
				this.RemCCS(this.la.val); 
			}
			if (this.la.kind == Parser._ppIf) {
				this.IfPragma(this.la.val); 
			}
			if (this.la.kind == Parser._ppElif) {
				this.ElifOrElsePragma(); 
			}
			if (this.la.kind == Parser._ppElse) {
				this.ElifOrElsePragma(); 
			}
			if (this.la.kind == Parser._ppEndif) {
			}
			if (this.la.kind == Parser._ppLine) {
			}
			if (this.la.kind == Parser._ppError) {
			}
			if (this.la.kind == Parser._ppWarning) {
			}
			if (this.la.kind == Parser._ppRegion) {
			}
			if (this.la.kind == Parser._ppEndReg) {
			}

            this.la = this.t;
        }
    }

    private  isKind( t : Token,  n : int) : bool {
        let k : int = t.kind;
        while(k >= 0) {
            if (k == n) return true;
            k = Parser.tBase[k];
        }
        return false;
    }

    private  Expect ( n : int) : void {
        if (this.isKind(this.la, n)) this.Get(); else { this.SynErr(n); }
    }

    private  StartOf ( s : int) : bool {
        return Parser.set[s][this.la.kind];
    }

    private  ExpectWeak ( n : int,  follow : int) : void {
        if (this.isKind(this.la, n)) this.Get();
        else {
            this.SynErr(n);
            while (!this.StartOf(follow)) this.Get();
        }
    }


    private  WeakSeparator( n : int,  syFol : int,  repFol : int) : bool {
        let kind : int = this.la.kind;
        if (this.isKind(this.la, n)) {this.Get(); return true;}
        else if (this.StartOf(repFol)) {return false;}
        else {
            this.SynErr(n);
            while (!(Parser.set[syFol][kind] || Parser.set[repFol][kind] || Parser.set[0][kind])) {
                this.Get();
                kind = this.la.kind;
            }
            return this.StartOf(syFol);
        }
    }

	private SkipNested(leftKind: int, rightKind: int) : void {
		// manage nested braces
		if(this.la.kind != rightKind) {
			for (let nested : int = 1; nested > 0;) {
				//print("==", this.la.line, nested, this.la.kind, this.la.val);
				if(this.la.kind == leftKind) ++nested;
				this.Get();
				if(this.la.kind == rightKind) --nested;
				else if(this.la.kind == Parser._EOF) break;
			}
		}
	}

	private SkipTill(endKind : int) : void {
		while(this.la.kind != endKind || this.la.kind != Parser._EOF) {
			this.Get();
		}
	}

	private SkipTillEOL() : void {
		let currLine : int = this.la.line;
		while(this.la.line == currLine || this.la.kind != Parser._EOF) {
			this.Get();
		}
	}

	private CS2_NT() : void {
		while (this.IsExternAliasDirective()) {
			this.ExternAliasDirective_NT();
		}
		while (this.isKind(this.la, Parser._usingKW)) {
			this.UsingDirective_NT();
		}
		while (this.IsGlobalAttrTarget()) {
			this.GlobalAttributes_NT();
		}
		while (this.StartOf(1 /* nt   NamespaceMemberDeclaration */)) {
			this.NamespaceMemberDeclaration_NT();
		}
	}

	private ExternAliasDirective_NT() : void {
		this.Expect(Parser._extern);
		this.Expect(Parser._ident);
		if (this.t.val != "alias") {
		 Error("alias expected");
		}
		
		this.Expect(Parser._ident);
		this.Expect(Parser._scolon);
	}

	private UsingDirective_NT() : void {
		this.Expect(Parser._usingKW);
        this.t.val = "//" + this.t.val;
		if (this.IsAssignment()) {
			this.Expect(Parser._ident);
			this.Expect(Parser._assgn);
		}
		this.TypeName_NT();
		this.Expect(Parser._scolon);
	}

	private GlobalAttributes_NT() : void {
		this.Expect(Parser._lbrack);
		this.Expect(Parser._ident);
		if (!(this.t.val == "assembly") && !("module" == this.t.val)) Error("global attribute target specifier \"assembly\" or \"module\" expected");
		
		this.Expect(Parser._colon);
		this.Attribute_NT();
		while (this.NotFinalComma()) {
			this.Expect(Parser._comma);
			this.Attribute_NT();
		}
		if (this.isKind(this.la, Parser._comma)) {
			this.Get();
		}
		this.Expect(Parser._rbrack);
	}

	private NamespaceMemberDeclaration_NT() : void {
		let m : Modifiers  = new Modifiers(this); 
		if (this.isKind(this.la, Parser._namespace)) {
			this.Get();
			this.Expect(Parser._ident);
			while (this.isKind(this.la, Parser._dot)) {
				this.Get();
				this.Expect(Parser._ident);
			}
			this.Expect(Parser._lbrace);
			while (this.IsExternAliasDirective()) {
				this.ExternAliasDirective_NT();
			}
			while (this.isKind(this.la, Parser._usingKW)) {
				this.UsingDirective_NT();
			}
			while (this.StartOf(1 /* nt   NamespaceMemberDeclaration */)) {
				this.NamespaceMemberDeclaration_NT();
			}
			this.Expect(Parser._rbrace);
			if (this.isKind(this.la, Parser._scolon)) {
				this.Get();
			}
		} else if (this.StartOf(2 /* iter  */)) {
			while (this.isKind(this.la, Parser._lbrack)) {
				this.Attributes_NT();
			}
			this.ModifierList_NT(m);
			this.TypeDeclaration_NT(m);
		} else this.SynErr(131);
	}

	private TypeName_NT() : void {
		this.Expect(Parser._ident);
		if (this.isKind(this.la, Parser._dblcolon)) {
			this.Get();
			this.Expect(Parser._ident);
		}
		if (this.isKind(this.la, Parser._lt)) {
			this.TypeArgumentList_NT();
		}
		while (this.isKind(this.la, Parser._dot)) {
			this.Get();
			this.Expect(Parser._ident);
			if (this.isKind(this.la, Parser._lt)) {
				this.TypeArgumentList_NT();
			}
		}
	}

	private Attributes_NT() : void {
		this.Expect(Parser._lbrack);
		if (this.IsAttrTargSpec()) {
			if (this.isKind(this.la, Parser._ident)) {
				this.Get();
			} else if (this.StartOf(3 /* nt   Keyword */)) {
				this.Keyword_NT();
			} else this.SynErr(132);
			this.Expect(Parser._colon);
		}
		this.Attribute_NT();
		while (this.la.kind == Parser._comma && this.Peek(1).kind != Parser._rbrack) {
			this.Expect(Parser._comma);
			this.Attribute_NT();
		}
		if (this.isKind(this.la, Parser._comma)) {
			this.Get();
		}
		this.Expect(Parser._rbrack);
	}

	private ModifierList_NT(m : Modifiers) : void {
		while (this.StartOf(4 /* alt   */)) {
			switch (this.la.kind) {
			case Parser._new: {
				this.Get();
				m.Add(Modifier._at_new); 
				break;
			}
			case Parser._public: {
				this.Get();
				m.Add(Modifier._at_public); 
				break;
			}
			case Parser._protected: {
				this.Get();
				m.Add(Modifier._at_protected); 
				break;
			}
			case Parser._internal: {
				this.Get();
				m.Add(Modifier._at_internal); 
				break;
			}
			case Parser._private: {
				this.Get();
				m.Add(Modifier._at_private); 
				break;
			}
			case Parser._unsafe: {
				this.Get();
				m.Add(Modifier._at_unsafe); 
				break;
			}
			case Parser._static: {
				this.Get();
				m.Add(Modifier._at_static); 
				break;
			}
			case Parser._readonly: {
				this.Get();
				m.Add(Modifier._at_readonly); 
				break;
			}
			case Parser._volatile: {
				this.Get();
				m.Add(Modifier._at_volatile); 
				break;
			}
			case Parser._virtual: {
				this.Get();
                this.t.val = "/*virtual*/";
				m.Add(Modifier._at_virtual); 
				break;
			}
			case Parser._sealed: {
				this.Get();
				m.Add(Modifier._at_sealed); 
				break;
			}
			case Parser._override: {
				this.Get();
                this.t.val = "/*override*/";
				m.Add(Modifier._at_override); 
				break;
			}
			case Parser._abstract: {
				this.Get();
				m.Add(Modifier._at_abstract); 
				break;
			}
			case Parser._extern: {
				this.Get();
				m.Add(Modifier._at_extern); 
				break;
			}
			}
		}
	}

	private TypeDeclaration_NT(m : Modifiers) : void {
		let dummy : TypeKind; 
		if (this.StartOf(5 /* opt   */)) {
			if (this.isKind(this.la, 119 /* "partial" */)) {
				this.Get();
			}
			if (this.isKind(this.la, Parser._class)) {
				m.Check(Modifier.classes);
                this.t.val = ""; //remove public/private for classes
				this.Get();
				this.Expect(Parser._ident);
				if (this.isKind(this.la, Parser._lt)) {
					this.TypeParameterList_NT();
				}
				if (this.isKind(this.la, Parser._colon)) {
					this.ClassBase_NT();
				}
				while (this.isKind(this.la, Parser._ident)) {
					this.TypeParameterConstraintsClause_NT();
				}
				this.ClassBody_NT();
				if (this.isKind(this.la, Parser._scolon)) {
					this.Get();
				}
			} else if (this.isKind(this.la, Parser._struct)) {
				m.Check(Modifier.nonClassTypes); 
				this.Get();
				this.Expect(Parser._ident);
				if (this.isKind(this.la, Parser._lt)) {
					this.TypeParameterList_NT();
				}
				if (this.isKind(this.la, Parser._colon)) {
					this.Get();
					this.TypeName_NT();
					while (this.isKind(this.la, Parser._comma)) {
						this.Get();
						this.TypeName_NT();
					}
				}
				while (this.isKind(this.la, Parser._ident)) {
					this.TypeParameterConstraintsClause_NT();
				}
				this.StructBody_NT();
				if (this.isKind(this.la, Parser._scolon)) {
					this.Get();
				}
			} else if (this.isKind(this.la, Parser._interface)) {
				m.Check(Modifier.nonClassTypes); 
				this.Get();
				this.Expect(Parser._ident);
				if (this.isKind(this.la, Parser._lt)) {
					this.TypeParameterList_NT();
				}
				if (this.isKind(this.la, Parser._colon)) {
					this.Get();
					this.TypeName_NT();
					while (this.isKind(this.la, Parser._comma)) {
						this.Get();
						this.TypeName_NT();
					}
				}
				while (this.isKind(this.la, Parser._ident)) {
					this.TypeParameterConstraintsClause_NT();
				}
				this.Expect(Parser._lbrace);
				while (this.StartOf(6 /* nt   InterfaceMemberDeclaration */)) {
					this.InterfaceMemberDeclaration_NT();
				}
				this.Expect(Parser._rbrace);
				if (this.isKind(this.la, Parser._scolon)) {
					this.Get();
				}
			} else this.SynErr(133);
		} else if (this.isKind(this.la, Parser._enum)) {
			m.Check(Modifier.nonClassTypes); 
			this.Get();
			this.Expect(Parser._ident);
			if (this.isKind(this.la, Parser._colon)) {
				this.Get();
				this.IntegralType_NT();
			}
			this.EnumBody_NT();
			if (this.isKind(this.la, Parser._scolon)) {
				this.Get();
			}
		} else if (this.isKind(this.la, Parser._delegate)) {
			m.Check(Modifier.nonClassTypes); 
			this.Get();
			dummy = this.Type_NT(true);
			this.Expect(Parser._ident);
			if (this.isKind(this.la, Parser._lt)) {
				this.TypeParameterList_NT();
			}
			this.Expect(Parser._lpar);
			if (this.StartOf(7 /* nt   FormalParameterList */)) {
				this.FormalParameterList_NT();
			}
			this.Expect(Parser._rpar);
			while (this.isKind(this.la, Parser._ident)) {
				this.TypeParameterConstraintsClause_NT();
			}
			this.Expect(Parser._scolon);
		} else this.SynErr(134);
	}

	private TypeParameterList_NT() : void {
		this.Expect(Parser._lt);
		while (this.isKind(this.la, Parser._lbrack)) {
			this.Attributes_NT();
		}
		this.Expect(Parser._ident);
		while (this.isKind(this.la, Parser._comma)) {
			this.Get();
			while (this.isKind(this.la, Parser._lbrack)) {
				this.Attributes_NT();
			}
			this.Expect(Parser._ident);
		}
		this.Expect(Parser._gt);
	}

	private ClassBase_NT() : void {
		this.Expect(Parser._colon);
        this.t.val = " extends";
		this.ClassType_NT();
		while (this.isKind(this.la, Parser._comma)) {
			this.Get();
			this.TypeName_NT();
		}
	}

	private TypeParameterConstraintsClause_NT() : void {
		this.Expect(Parser._ident);
		if (this.t.val != "where") {
		 Error("type parameter constraints clause must start with: where");
		}
		
		this.Expect(Parser._ident);
		this.Expect(Parser._colon);
		if (this.StartOf(8 /* alt   */)) {
			if (this.isKind(this.la, Parser._class)) {
				this.Get();
			} else if (this.isKind(this.la, Parser._struct)) {
				this.Get();
			} else if (this.isKind(this.la, Parser._object)) {
				this.Get();
			} else if (this.isKind(this.la, Parser._string)) {
				this.Get();
			} else {
				this.TypeName_NT();
			}
			while (this.la.kind == Parser._comma && this.Peek(1).kind != Parser._new) {
				this.Expect(Parser._comma);
				this.TypeName_NT();
			}
			if (this.isKind(this.la, Parser._comma)) {
				this.Get();
				this.Expect(Parser._new);
				this.Expect(Parser._lpar);
				this.Expect(Parser._rpar);
			}
		} else if (this.isKind(this.la, Parser._new)) {
			this.Get();
			this.Expect(Parser._lpar);
			this.Expect(Parser._rpar);
		} else this.SynErr(135);
	}

	private ClassBody_NT() : void {
		this.Expect(Parser._lbrace);
		while (this.StartOf(9 /* iter  */)) {
			while (this.isKind(this.la, Parser._lbrack)) {
				this.Attributes_NT();
			}
			let m : Modifiers = new Modifiers(this); 
			this.ModifierList_NT(m);
			this.ClassMemberDeclaration_NT(m);
		}
		this.Expect(Parser._rbrace);
	}

	private StructBody_NT() : void {
		this.Expect(Parser._lbrace);
		while (this.StartOf(10 /* iter  */)) {
			while (this.isKind(this.la, Parser._lbrack)) {
				this.Attributes_NT();
			}
			let m : Modifiers = new Modifiers(this); 
			this.ModifierList_NT(m);
			this.StructMemberDeclaration_NT(m);
		}
		this.Expect(Parser._rbrace);
	}

	private InterfaceMemberDeclaration_NT() : void {
		let m : Modifiers = new Modifiers(this);
		let dummy : TypeKind;
		
		while (this.isKind(this.la, Parser._lbrack)) {
			this.Attributes_NT();
		}
		if (this.isKind(this.la, Parser._new)) {
			this.Get();
		}
		if (this.StartOf(11 /* nt   Type */)) {
			dummy = this.Type_NT(true);
			if (this.isKind(this.la, Parser._ident)) {
				this.Get();
				if (this.isKind(this.la, Parser._lpar) || this.isKind(this.la, Parser._lt)) {
					if (this.isKind(this.la, Parser._lt)) {
						this.TypeParameterList_NT();
					}
					this.Expect(Parser._lpar);
					if (this.StartOf(7 /* nt   FormalParameterList */)) {
						this.FormalParameterList_NT();
					}
					this.Expect(Parser._rpar);
					while (this.isKind(this.la, Parser._ident)) {
						this.TypeParameterConstraintsClause_NT();
					}
					this.Expect(Parser._scolon);
				} else if (this.isKind(this.la, Parser._lbrace)) {
					this.Get();
					this.InterfaceAccessors_NT(m);
					this.Expect(Parser._rbrace);
				} else this.SynErr(136);
			} else if (this.isKind(this.la, Parser._this)) {
				this.Get();
				this.Expect(Parser._lbrack);
				this.FormalParameterList_NT();
				this.Expect(Parser._rbrack);
				this.Expect(Parser._lbrace);
				this.InterfaceAccessors_NT(m);
				this.Expect(Parser._rbrace);
			} else this.SynErr(137);
		} else if (this.isKind(this.la, Parser._event)) {
			this.Get();
			dummy = this.Type_NT(false);
			this.Expect(Parser._ident);
			this.Expect(Parser._scolon);
		} else this.SynErr(138);
	}

	private IntegralType_NT() : void {
		switch (this.la.kind) {
		case Parser._sbyte: {
			this.Get();
			break;
		}
		case Parser._byte: {
			this.Get();
			break;
		}
		case Parser._short: {
			this.Get();
			break;
		}
		case Parser._ushort: {
			this.Get();
			break;
		}
		case Parser._int: {
			this.Get();
			break;
		}
		case Parser._uint: {
			this.Get();
			break;
		}
		case Parser._long: {
			this.Get();
			break;
		}
		case Parser._ulong: {
			this.Get();
			break;
		}
		case Parser._char: {
			this.Get();
			break;
		}
		default: this.SynErr(139); break;
		}
	}

	private EnumBody_NT() : void {
		this.Expect(Parser._lbrace);
		if (this.isKind(this.la, Parser._ident) || this.isKind(this.la, Parser._lbrack)) {
			this.EnumMemberDeclaration_NT();
			while (this.NotFinalComma()) {
				this.Expect(Parser._comma);
				this.EnumMemberDeclaration_NT();
			}
			if (this.isKind(this.la, Parser._comma)) {
				this.Get();
			}
		}
		this.Expect(Parser._rbrace);
	}

	private Type_NT(voidAllowed : bool) : TypeKind {
		let type : TypeKind;
		type = TypeKind.simple; 
		if (this.StartOf(12 /* nt   PrimitiveType */)) {
			this.PrimitiveType_NT();
		} else if (this.isKind(this.la, Parser._ident) || this.isKind(this.la, Parser._object) || this.isKind(this.la, Parser._string)) {
			this.ClassType_NT();
		} else if (this.isKind(this.la, Parser._void)) {
			this.Get();
			type = TypeKind._at_void; 
		} else this.SynErr(140);
		if (this.isKind(this.la, Parser._question)) {
			this.Get();
			if (type == TypeKind._at_void) { Error("Unexpected token ?, void must not be nullable."); } 
		}
		type = this.PointerOrArray_NT(type);
		if (type == TypeKind._at_void && !voidAllowed) { Error("type expected, void found, maybe you mean void*"); } 
		return type;
	}

	private FormalParameterList_NT() : void {
		let type : TypeKind; 
		while (this.isKind(this.la, Parser._lbrack)) {
			this.Attributes_NT();
		}
		if (this.StartOf(13 /* opt   */)) {
			if (this.isKind(this.la, Parser._xout) || this.isKind(this.la, Parser._ref)) {
				if (this.isKind(this.la, Parser._ref)) {
					this.Get();
				} else {
					this.Get();
				}
			}
			type = this.Type_NT(false);
			let saved_type : string = this.t.val;
			this.t.val = "";
			this.Expect(Parser._ident);
			this.classMemberFuncParamNames[this.t.val] = true;
			this.t.val += " : " + saved_type;
			if (this.isKind(this.la, Parser._assgn)) {
				this.Get();
				this.Expression_NT();
			}
			if (this.isKind(this.la, Parser._comma)) {
				this.Get();
				this.FormalParameterList_NT();
			}
		} else if (this.isKind(this.la, Parser._params)) {
			this.Get();
			type = this.Type_NT(false);
			if (type != TypeKind.array) { Error("params argument must be an array"); } 
			this.Expect(Parser._ident);
			if (this.isKind(this.la, Parser._assgn)) {
				this.Get();
				this.Expression_NT();
			}
		} else this.SynErr(141);
	}

	private ClassType_NT() : void {
		if (this.isKind(this.la, Parser._ident)) {
			this.TypeName_NT();
		} else if (this.isKind(this.la, Parser._object) || this.isKind(this.la, Parser._string)) {
			this.InternalClassType_NT();
		} else this.SynErr(142);
	}

	private ClassMemberDeclaration_NT(m : Modifiers) : void {
		if (this.StartOf(14 /* nt   StructMemberDeclaration */)) {
			this.StructMemberDeclaration_NT(m);
		} else if (this.isKind(this.la, Parser._tilde)) {
			this.Get();
			this.t.val = "/*" + this.t.val;
			this.Expect(Parser._ident);
			this.Expect(Parser._lpar);
			this.Expect(Parser._rpar);
			if (this.isKind(this.la, Parser._lbrace)) {
				this.Block_NT();
				this.t.val += "*/";
			} else if (this.isKind(this.la, Parser._scolon)) {
				this.Get();
			} else this.SynErr(143);
		} else this.SynErr(144);
	}

	private StructMemberDeclaration_NT(m : Modifiers) : void {
		let type : TypeKind; let op : Operator; 
		if (this.isKind(this.la, Parser._const)) {
			m.Check(Modifier.constants); 
			this.Get();
            this.t.val = "static readonly";
			type = this.Type_NT(false);
			let saved_type : string = this.t.val;
			this.t.val = "";
			this.Expect(Parser._ident);
			this.classMemberNames[this.t.val] = true;
			this.t.val += " : " + saved_type;
			this.Expect(Parser._assgn);
			this.Expression_NT();
			while (this.isKind(this.la, Parser._comma)) {
				this.Get();
				this.Expect(Parser._ident);
				this.classMemberNames[this.t.val] = true;
				this.Expect(Parser._assgn);
				this.Expression_NT();
			}
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._event)) {
			m.Check(Modifier.propEvntMeths); 
			this.Get();
			type = this.Type_NT(false);
			if (this.IsFieldDecl()) {
				this.VariableDeclarators_NT(m);
				this.Expect(Parser._scolon);
			} else if (this.isKind(this.la, Parser._ident)) {
				this.TypeName_NT();
				this.Expect(Parser._lbrace);
				this.EventAccessorDeclarations_NT();
				this.Expect(Parser._rbrace);
			} else this.SynErr(145);
		} else if (this.la.kind == Parser._ident && this.Peek(1).kind == Parser._lpar) {
			m.Check(Modifier.constructors|Modifier.staticConstr); 
            this.t.val = "";
			this.Expect(Parser._ident);
			this.t.val = "constructor";
			this.Expect(Parser._lpar);
			if (this.StartOf(7 /* sem   */)) {
				m.Check(Modifier.constructors); 
				this.FormalParameterList_NT();
			}
			this.Expect(Parser._rpar);
			if (this.isKind(this.la, Parser._colon)) {
				m.Check(Modifier.constructors); 
				this.Get();
				if (this.isKind(this.la, Parser._base)) {
					this.Get();
                    this.t.val = "super";
				} else if (this.isKind(this.la, Parser._this)) {
					this.Get();
				} else this.SynErr(146);
				this.Expect(Parser._lpar);
				if (this.StartOf(15 /* nt   Argument */)) {
					this.Argument_NT();
					while (this.isKind(this.la, Parser._comma)) {
						this.Get();
						this.Argument_NT();
					}
				}
				this.Expect(Parser._rpar);
			}
			if (this.isKind(this.la, Parser._lbrace)) {
				this.Block_NT();
			} else if (this.isKind(this.la, Parser._scolon)) {
				this.Get();
			} else this.SynErr(147);
		} else if (this.StartOf(11 /* nt   Type */)) {
			type = this.Type_NT(true);
			if (this.isKind(this.la, Parser._operator)) {
				m.Check(Modifier.operators);
				m.CheckMust(Modifier.operatorsMust);
				if (type == TypeKind._at_void) { Error("operator not allowed on void"); }
				
				this.Get();
				op = this.OverloadableOp_NT();
				this.Expect(Parser._lpar);
				type = this.Type_NT(false);
				this.Expect(Parser._ident);
				if (this.isKind(this.la, Parser._comma)) {
					this.Get();
					type = this.Type_NT(false);
					this.Expect(Parser._ident);
					if ((op & Operator.binary) == 0) Error("too many operands for unary operator"); 
				} else if (this.isKind(this.la, Parser._rpar)) {
					if ((op & Operator.unary) == 0) Error("too few operands for binary operator"); 
				} else this.SynErr(148);
				this.Expect(Parser._rpar);
				if (this.isKind(this.la, Parser._lbrace)) {
					this.Block_NT();
				} else if (this.isKind(this.la, Parser._scolon)) {
					this.Get();
				} else this.SynErr(149);
			} else if (this.IsFieldDecl()) {
				m.Check(Modifier.fields);
				if (type == TypeKind._at_void) { Error("field type must not be void"); }
				
				this.VariableDeclarators_NT(m);
				this.Expect(Parser._scolon);
			} else if (this.isKind(this.la, Parser._ident)) {
				let saved_type : string  = this.t.val;
				this.t.val = m.IsNone ? "private " : "";
				this.MemberName_NT();
				if (this.isKind(this.la, Parser._lbrace)) {
					m.Check(Modifier.propEvntMeths);
					if (type == TypeKind._at_void) { Error("property type must not be void"); }
					
					this.Get();
					this.AccessorDeclarations_NT(m);
					this.Expect(Parser._rbrace);
				} else if (this.isKind(this.la, Parser._dot)) {
					m.Check(Modifier.indexers);
					if (type == TypeKind._at_void) { Error("indexer type must not be void"); }
					
					this.Get();
					this.Expect(Parser._this);
					this.Expect(Parser._lbrack);
					this.FormalParameterList_NT();
					this.Expect(Parser._rbrack);
                    this.t.val += " : " + saved_type;
					this.Expect(Parser._lbrace);
					this.AccessorDeclarations_NT(m);
					this.Expect(Parser._rbrace);
				} else if (this.isKind(this.la, Parser._lpar) || this.isKind(this.la, Parser._lt)) {
					m.Check(Modifier.propEvntMeths); 
					if (this.isKind(this.la, Parser._lt)) {
						this.TypeParameterList_NT();
					}
					this.Expect(Parser._lpar);
					if (this.StartOf(7 /* nt   FormalParameterList */)) {
						this.FormalParameterList_NT();
					}
					this.Expect(Parser._rpar);
                    this.t.val += " : " + saved_type;
					while (this.isKind(this.la, Parser._ident)) {
						this.TypeParameterConstraintsClause_NT();
					}
					if (this.isKind(this.la, Parser._lbrace)) {
						this.Block_NT();
					} else if (this.isKind(this.la, Parser._scolon)) {
						this.Get();
					} else this.SynErr(150);
				} else this.SynErr(151);
			} else if (this.isKind(this.la, Parser._this)) {
				m.Check(Modifier.indexers);
				if (type == TypeKind._at_void) { Error("indexer type must not be void"); }
				
				this.Get();
				this.Expect(Parser._lbrack);
				this.FormalParameterList_NT();
				this.Expect(Parser._rbrack);
				this.Expect(Parser._lbrace);
				this.AccessorDeclarations_NT(m);
				this.Expect(Parser._rbrace);
			} else this.SynErr(152);
		} else if (this.isKind(this.la, Parser._explicit) || this.isKind(this.la, Parser._implicit)) {
			m.Check(Modifier.operators);
			m.CheckMust(Modifier.operatorsMust);
			
			if (this.isKind(this.la, Parser._implicit)) {
				this.Get();
			} else {
				this.Get();
			}
			this.Expect(Parser._operator);
			type = this.Type_NT(false);
			if (type == TypeKind._at_void) { Error("cast type must not be void"); } 
			this.Expect(Parser._lpar);
			type = this.Type_NT(false);
			this.Expect(Parser._ident);
			this.Expect(Parser._rpar);
			if (this.isKind(this.la, Parser._lbrace)) {
				this.Block_NT();
			} else if (this.isKind(this.la, Parser._scolon)) {
				this.Get();
			} else this.SynErr(153);
		} else if (this.StartOf(16 /* nt   TypeDeclaration */)) {
			this.TypeDeclaration_NT(m);
		} else this.SynErr(154);
	}

	private EnumMemberDeclaration_NT() : void {
		while (this.isKind(this.la, Parser._lbrack)) {
			this.Attributes_NT();
		}
		this.Expect(Parser._ident);
		if (this.isKind(this.la, Parser._assgn)) {
			this.Get();
			this.Expression_NT();
		}
	}

	private Block_NT() : void {
		this.Expect(Parser._lbrace);
		while (this.StartOf(17 /* nt   Statement */)) {
			this.Statement_NT();
		}
		this.Expect(Parser._rbrace);
	}

	private Expression_NT() : void {
		this.Unary_NT();
		if (Parser.assgnOps.Get(this.la.kind) || (this.la.kind == Parser._gt && this.Peek(1).kind == Parser._gteq)) {
			this.AssignmentOperator_NT();
			this.Expression_NT();
		} else if (this.StartOf(18 /* nt   NullCoalescingExpr */)) {
			this.NullCoalescingExpr_NT();
			if (this.isKind(this.la, Parser._question)) {
				this.Get();
				this.Expression_NT();
				this.Expect(Parser._colon);
				this.Expression_NT();
			}
		} else this.SynErr(155);
	}

	private VariableDeclarators_NT(m : Modifiers) : void {
		let saved_type : string = this.t.val;
		this.t.val = "";
		this.Expect(Parser._ident);
		this.classMemberNames[this.t.val] = true;
		this.t.spaceBefore = ""; this.t.val = (m.IsNone ? "private " : "") + this.t.val + " : " + saved_type;
		if (this.isKind(this.la, Parser._assgn)) {
			this.Get();
			this.VariableInitializer_NT();
		}
		while (this.isKind(this.la, Parser._comma)) {
			this.Get();
			this.Expect(Parser._ident);
			this.classMemberNames[this.t.val] = true;
			this.t.val += " : " + saved_type;
			if (this.isKind(this.la, Parser._assgn)) {
				this.Get();
				this.VariableInitializer_NT();
			}
		}
	}

	private EventAccessorDeclarations_NT() : void {
		let addFound : bool = false, remFound : bool = false; 
		while (this.isKind(this.la, Parser._lbrack)) {
			this.Attributes_NT();
		}
		if ("add" == this.la.val) {
			this.Expect(Parser._ident);
			addFound = true; 
		} else if ("remove" == this.la.val) {
			this.Expect(Parser._ident);
			remFound = true; 
		} else if (this.isKind(this.la, Parser._ident)) {
			this.Get();
			Error("add or remove expected"); 
		} else this.SynErr(156);
		this.Block_NT();
		if (this.isKind(this.la, Parser._ident) || this.isKind(this.la, Parser._lbrack)) {
			while (this.isKind(this.la, Parser._lbrack)) {
				this.Attributes_NT();
			}
			if ("add" == this.la.val) {
				this.Expect(Parser._ident);
				if (addFound) Error("add already declared");    
			} else if ("remove" == this.la.val) {
				this.Expect(Parser._ident);
				if (remFound) Error("remove already declared"); 
			} else if (this.isKind(this.la, Parser._ident)) {
				this.Get();
				Error("add or remove expected"); 
			} else this.SynErr(157);
			this.Block_NT();
		}
	}

	private Argument_NT() : void {
		if (this.isKind(this.la, Parser._xout) || this.isKind(this.la, Parser._ref)) {
			if (this.isKind(this.la, Parser._ref)) {
				this.Get();
			} else {
				this.Get();
			}
		}
		this.Expression_NT();
	}

	private OverloadableOp_NT() : Operator {
		let op : Operator;
		op = Operator.plus; 
		switch (this.la.kind) {
		case Parser._plus: {
			this.Get();
			break;
		}
		case Parser._minus: {
			this.Get();
			op = Operator.minus; 
			break;
		}
		case Parser._not: {
			this.Get();
			op = Operator.not; 
			break;
		}
		case Parser._tilde: {
			this.Get();
			op = Operator.tilde; 
			break;
		}
		case Parser._inc: {
			this.Get();
			op = Operator.inc; 
			break;
		}
		case Parser._dec: {
			this.Get();
			op = Operator.dec; 
			break;
		}
		case Parser._true: {
			this.Get();
			op = Operator._at_true; 
			break;
		}
		case Parser._false: {
			this.Get();
			op = Operator._at_false; 
			break;
		}
		case Parser._times: {
			this.Get();
			op = Operator.times; 
			break;
		}
		case 127 /* "/" */: {
			this.Get();
			op = Operator.div; 
			break;
		}
		case 128 /* "%" */: {
			this.Get();
			op = Operator.mod; 
			break;
		}
		case Parser._and: {
			this.Get();
			op = Operator.and; 
			break;
		}
		case 124 /* "|" */: {
			this.Get();
			op = Operator.or; 
			break;
		}
		case 125 /* "^" */: {
			this.Get();
			op = Operator._at_or; 
			break;
		}
		case Parser._ltlt: {
			this.Get();
			op = Operator.lshift; 
			break;
		}
		case Parser._eq: {
			this.Get();
			op = Operator.eq; 
			break;
		}
		case Parser._neq: {
			this.Get();
			op = Operator.neq; 
			break;
		}
		case Parser._gt: {
			this.Get();
			op = Operator.gt; 
			if (this.isKind(this.la, Parser._gt)) {
				if (this.la.pos > this.t.pos+1) Error("no whitespace allowed in right shift operator"); 
				this.Get();
				op = Operator.rshift; 
			}
			break;
		}
		case Parser._lt: {
			this.Get();
			op = Operator.lt; 
			break;
		}
		case Parser._gteq: {
			this.Get();
			op = Operator.gte; 
			break;
		}
		case 126 /* "<=" */: {
			this.Get();
			op = Operator.lte; 
			break;
		}
		default: this.SynErr(158); break;
		}
		return op;
	}

	private MemberName_NT() : void {
		this.Expect(Parser._ident);
		if(!this.classMemberNames.hasOwnProperty(this.t.val)) //Allow overloaded names
            this.classMemberNames[this.t.val] = true;
		if (this.isKind(this.la, Parser._dblcolon)) {
			this.Get();
			this.Expect(Parser._ident);
		}
		if (this.la.kind == Parser._lt && this.IsPartOfMemberName()) {
			this.TypeArgumentList_NT();
		}
		while (this.la.kind == Parser._dot && this.Peek(1).kind == Parser._ident) {
			this.Expect(Parser._dot);
			this.Expect(Parser._ident);
			if (this.la.kind == Parser._lt && this.IsPartOfMemberName()) {
				this.TypeArgumentList_NT();
			}
		}
	}

	private AccessorDeclarations_NT(m : Modifiers) : void {
		let am : Modifiers = new Modifiers(this);
		let getFound : bool = false, setFound : bool = false;
		
		while (this.isKind(this.la, Parser._lbrack)) {
			this.Attributes_NT();
		}
		this.ModifierList_NT(am);
		am.Check2(Modifier.accessorsPossib1, Modifier.accessorsPossib2); 
		if ("get" == this.la.val) {
			this.Expect(Parser._ident);
			getFound = true; 
		} else if ("set" == this.la.val) {
			this.Expect(Parser._ident);
			setFound = true; 
		} else if (this.isKind(this.la, Parser._ident)) {
			this.Get();
			Error("set or get expected"); 
		} else this.SynErr(159);
		if (this.isKind(this.la, Parser._lbrace)) {
			this.Block_NT();
		} else if (this.isKind(this.la, Parser._scolon)) {
			this.Get();
		} else this.SynErr(160);
		if (this.StartOf(19 /* sem   */)) {
			am = new Modifiers(this); 
			while (this.isKind(this.la, Parser._lbrack)) {
				this.Attributes_NT();
			}
			this.ModifierList_NT(am);
			am.Check2(Modifier.accessorsPossib1, Modifier.accessorsPossib2); 
			if ("get" == this.la.val) {
				this.Expect(Parser._ident);
				if (getFound) Error("get already declared");  
			} else if ("set" == this.la.val) {
				this.Expect(Parser._ident);
				if (setFound) Error("set already declared");  
			} else if (this.isKind(this.la, Parser._ident)) {
				this.Get();
				Error("set or get expected"); 
			} else this.SynErr(161);
			if (this.isKind(this.la, Parser._lbrace)) {
				this.Block_NT();
			} else if (this.isKind(this.la, Parser._scolon)) {
				this.Get();
			} else this.SynErr(162);
		}
	}

	private InterfaceAccessors_NT(m : Modifiers) : void {
		let getFound : bool = false, setFound : bool = false; 
		while (this.isKind(this.la, Parser._lbrack)) {
			this.Attributes_NT();
		}
		if ("get" == this.la.val) {
			this.Expect(Parser._ident);
			getFound = true; 
		} else if ("set" == this.la.val) {
			this.Expect(Parser._ident);
			setFound = true; 
		} else if (this.isKind(this.la, Parser._ident)) {
			this.Get();
			Error("set or get expected"); 
		} else this.SynErr(163);
		this.Expect(Parser._scolon);
		if (this.isKind(this.la, Parser._ident) || this.isKind(this.la, Parser._lbrack)) {
			while (this.isKind(this.la, Parser._lbrack)) {
				this.Attributes_NT();
			}
			if ("get" == this.la.val) {
				this.Expect(Parser._ident);
				if (getFound) Error("get already declared");  
			} else if ("set" == this.la.val) {
				this.Expect(Parser._ident);
				if (setFound) Error("set already declared");  
			} else if (this.isKind(this.la, Parser._ident)) {
				this.Get();
				Error("set or get expected"); 
			} else this.SynErr(164);
			this.Expect(Parser._scolon);
		}
	}

	private LocalVariableDeclaration_NT() : void {
		let dummy : TypeKind; 
		dummy = this.Type_NT(false);
		let saved_type : string  = this.t.val;
		this.t.val = "";
		this.LocalVariableDeclarator_NT(saved_type, true);
		while (this.isKind(this.la, Parser._comma)) {
			this.Get();
			this.LocalVariableDeclarator_NT(saved_type, false);
		}
	}

	private LocalVariableDeclarator_NT(saved_type: string, withLet: bool) : void {
		let dummy : TypeKind; 
		this.Expect(Parser._ident);
		this.t.spaceBefore = ""; this.t.val = (withLet ? "let " : "") + this.t.val + " : " + saved_type;
		if (this.isKind(this.la, Parser._assgn)) {
			this.Get();
			if (this.StartOf(20 /* nt   VariableInitializer */)) {
				this.VariableInitializer_NT();
			} else if (this.isKind(this.la, Parser._stackalloc)) {
				this.Get();
				dummy = this.Type_NT(false);
				this.Expect(Parser._lbrack);
				this.Expression_NT();
				this.Expect(Parser._rbrack);
			} else this.SynErr(165);
		}
	}

	private VariableInitializer_NT() : void {
		if (this.StartOf(21 /* nt   Expression */)) {
			this.Expression_NT();
		} else if (this.isKind(this.la, Parser._lbrace)) {
			this.ArrayInitializer_NT();
		} else this.SynErr(166);
	}

	private ArrayInitializer_NT() : void {
		this.Expect(Parser._lbrace);
        this.t.val = "[";
		if (this.StartOf(20 /* nt   VariableInitializer */)) {
			this.VariableInitializer_NT();
			while (this.NotFinalComma()) {
				this.Expect(Parser._comma);
				this.VariableInitializer_NT();
			}
			if (this.isKind(this.la, Parser._comma)) {
				this.Get();
			}
		}
		this.Expect(Parser._rbrace);
        this.t.val = "]";
	}

	private Attribute_NT() : void {
		this.TypeName_NT();
		if (this.isKind(this.la, Parser._lpar)) {
			this.AttributeArguments_NT();
		}
	}

	private Keyword_NT() : void {
		switch (this.la.kind) {
		case Parser._abstract: {
			this.Get();
			break;
		}
		case Parser._as: {
			this.Get();
			break;
		}
		case Parser._base: {
			this.Get();
			break;
		}
		case Parser._bool: {
			this.Get();
			break;
		}
		case Parser._break: {
			this.Get();
			break;
		}
		case Parser._byte: {
			this.Get();
			break;
		}
		case Parser._case: {
			this.Get();
			break;
		}
		case Parser._catch: {
			this.Get();
			break;
		}
		case Parser._char: {
			this.Get();
			break;
		}
		case Parser._checked: {
			this.Get();
			break;
		}
		case Parser._class: {
			this.Get();
			break;
		}
		case Parser._const: {
			this.Get();
			break;
		}
		case Parser._continue: {
			this.Get();
			break;
		}
		case Parser._decimal: {
			this.Get();
			break;
		}
		case Parser._default: {
			this.Get();
			break;
		}
		case Parser._delegate: {
			this.Get();
			break;
		}
		case Parser._do: {
			this.Get();
			break;
		}
		case Parser._double: {
			this.Get();
			break;
		}
		case Parser._else: {
			this.Get();
			break;
		}
		case Parser._enum: {
			this.Get();
			break;
		}
		case Parser._event: {
			this.Get();
			break;
		}
		case Parser._explicit: {
			this.Get();
			break;
		}
		case Parser._extern: {
			this.Get();
			break;
		}
		case Parser._false: {
			this.Get();
			break;
		}
		case Parser._finally: {
			this.Get();
			break;
		}
		case Parser._fixed: {
			this.Get();
			break;
		}
		case Parser._float: {
			this.Get();
			break;
		}
		case Parser._for: {
			this.Get();
			break;
		}
		case Parser._foreach: {
			this.Get();
            this.t.val = "for";
			break;
		}
		case Parser._goto: {
			this.Get();
			break;
		}
		case Parser._if: {
			this.Get();
			break;
		}
		case Parser._implicit: {
			this.Get();
			break;
		}
		case Parser._in: {
			this.Get();
			break;
		}
		case Parser._int: {
			this.Get();
			break;
		}
		case Parser._interface: {
			this.Get();
			break;
		}
		case Parser._internal: {
			this.Get();
			break;
		}
		case Parser._is: {
			this.Get();
			break;
		}
		case Parser._lock: {
			this.Get();
			break;
		}
		case Parser._long: {
			this.Get();
			break;
		}
		case Parser._namespace: {
			this.Get();
			break;
		}
		case Parser._new: {
			this.Get();
			break;
		}
		case Parser._null: {
			this.Get();
			break;
		}
		case Parser._object: {
			this.Get();
			break;
		}
		case Parser._operator: {
			this.Get();
			break;
		}
		case Parser._xout: {
			this.Get();
			break;
		}
		case Parser._override: {
			this.Get();
			break;
		}
		case Parser._params: {
			this.Get();
			break;
		}
		case Parser._private: {
			this.Get();
			break;
		}
		case Parser._protected: {
			this.Get();
			break;
		}
		case Parser._public: {
			this.Get();
			break;
		}
		case Parser._readonly: {
			this.Get();
			break;
		}
		case Parser._ref: {
			this.Get();
			break;
		}
		case Parser._return: {
			this.Get();
			break;
		}
		case Parser._sbyte: {
			this.Get();
			break;
		}
		case Parser._sealed: {
			this.Get();
			break;
		}
		case Parser._short: {
			this.Get();
			break;
		}
		case Parser._sizeof: {
			this.Get();
			break;
		}
		case Parser._stackalloc: {
			this.Get();
			break;
		}
		case Parser._static: {
			this.Get();
			break;
		}
		case Parser._string: {
			this.Get();
			break;
		}
		case Parser._struct: {
			this.Get();
			break;
		}
		case Parser._switch: {
			this.Get();
			break;
		}
		case Parser._this: {
			this.Get();
			break;
		}
		case Parser._throw: {
			this.Get();
			break;
		}
		case Parser._true: {
			this.Get();
			break;
		}
		case Parser._try: {
			this.Get();
			break;
		}
		case Parser._typeof: {
			this.Get();
			break;
		}
		case Parser._uint: {
			this.Get();
			break;
		}
		case Parser._ulong: {
			this.Get();
			break;
		}
		case Parser._unchecked: {
			this.Get();
			break;
		}
		case Parser._unsafe: {
			this.Get();
			break;
		}
		case Parser._ushort: {
			this.Get();
			break;
		}
		case Parser._usingKW: {
			this.Get();
			break;
		}
		case Parser._virtual: {
			this.Get();
            this.t.val = "/*virtual*/";
			break;
		}
		case Parser._void: {
			this.Get();
			break;
		}
		case Parser._volatile: {
			this.Get();
			break;
		}
		case Parser._while: {
			this.Get();
			break;
		}
		default: this.SynErr(167); break;
		}
	}

	private AttributeArguments_NT() : void {
		let nameFound : bool = false; 
		this.Expect(Parser._lpar);
		if (this.StartOf(21 /* opt   */)) {
			if (this.IsAssignment()) {
				nameFound = true; 
				this.Expect(Parser._ident);
				this.Expect(Parser._assgn);
			}
			this.Expression_NT();
			while (this.isKind(this.la, Parser._comma)) {
				this.Get();
				if (this.IsAssignment()) {
					nameFound = true; 
					this.Expect(Parser._ident);
					this.Expect(Parser._assgn);
				} else if (this.StartOf(21 /* sem   */)) {
					if (nameFound) Error("no positional argument after named arguments"); 
				} else this.SynErr(168);
				this.Expression_NT();
			}
		}
		this.Expect(Parser._rpar);
	}

	private PrimitiveType_NT() : void {
		if (this.StartOf(22 /* nt   IntegralType */)) {
			this.IntegralType_NT();
		} else if (this.isKind(this.la, Parser._float)) {
			this.Get();
		} else if (this.isKind(this.la, Parser._double)) {
			this.Get();
		} else if (this.isKind(this.la, Parser._decimal)) {
			this.Get();
		} else if (this.isKind(this.la, Parser._bool)) {
			this.Get();
		} else this.SynErr(169);
	}

	private PointerOrArray_NT(type : TypeKind) : TypeKind {
		while (this.IsPointerOrDims()) {
			if (this.isKind(this.la, Parser._times)) {
				this.Get();
				type = TypeKind.pointer; 
			} else if (this.isKind(this.la, Parser._lbrack)) {
				this.Get();
				while (this.isKind(this.la, Parser._comma)) {
					this.Get();
				}
				this.Expect(Parser._rbrack);
				type = TypeKind.array; 
			} else this.SynErr(170);
		}
        return type;
	}

	private ResolvedType_NT() : void {
		let type : TypeKind = TypeKind.simple; 
		if (this.StartOf(12 /* nt   PrimitiveType */)) {
			this.PrimitiveType_NT();
		} else if (this.isKind(this.la, Parser._object)) {
			this.Get();
		} else if (this.isKind(this.la, Parser._string)) {
			this.Get();
		} else if (this.isKind(this.la, Parser._ident)) {
			this.Get();
			if (this.isKind(this.la, Parser._dblcolon)) {
				this.Get();
				this.Expect(Parser._ident);
			}
			if (this.IsGeneric()) {
				this.TypeArgumentList_NT();
			}
			while (this.isKind(this.la, Parser._dot)) {
				this.Get();
				this.Expect(Parser._ident);
				if (this.IsGeneric()) {
					this.TypeArgumentList_NT();
				}
			}
		} else if (this.isKind(this.la, Parser._void)) {
			this.Get();
			type = TypeKind._at_void; 
		} else this.SynErr(171);
		type = this.PointerOrArray_NT(type);
		if (type == TypeKind._at_void) Error("type expected, void found, maybe you mean void*"); 
	}

	private TypeArgumentList_NT() : void {
		let dummy : TypeKind; 
		this.Expect(Parser._lt);
		if (this.StartOf(11 /* nt   Type */)) {
			dummy = this.Type_NT(false);
		}
		while (this.isKind(this.la, Parser._comma)) {
			this.Get();
			if (this.StartOf(11 /* nt   Type */)) {
				dummy = this.Type_NT(false);
			}
		}
		this.Expect(Parser._gt);
	}

	private InternalClassType_NT() : void {
		if (this.isKind(this.la, Parser._object)) {
			this.Get();
		} else if (this.isKind(this.la, Parser._string)) {
			this.Get();
		} else this.SynErr(172);
	}

	private Statement_NT() : void {
		let dummy : TypeKind; 
		if (this.la.kind == Parser._ident && this.Peek(1).kind == Parser._colon) {
			this.Expect(Parser._ident);
			this.Expect(Parser._colon);
			this.Statement_NT();
		} else if (this.isKind(this.la, Parser._const)) {
			this.Get();
			dummy = this.Type_NT(false);
			this.Expect(Parser._ident);
			this.Expect(Parser._assgn);
			this.Expression_NT();
			while (this.isKind(this.la, Parser._comma)) {
				this.Get();
				this.Expect(Parser._ident);
				this.Expect(Parser._assgn);
				this.Expression_NT();
			}
			this.Expect(Parser._scolon);
		} else if (this.IsLocalVarDecl()) {
			this.LocalVariableDeclaration_NT();
			this.Expect(Parser._scolon);
		} else if (this.StartOf(23 /* nt   EmbeddedStatement */)) {
			this.EmbeddedStatement_NT();
		} else this.SynErr(173);
	}

	private EmbeddedStatement_NT() : void {
		let type : TypeKind; 
		if (this.isKind(this.la, Parser._lbrace)) {
			this.Block_NT();
		} else if (this.isKind(this.la, Parser._scolon)) {
			this.Get();
		} else if (this.la.kind == Parser._checked && this.Peek(1).kind == Parser._lbrace) {
			this.Expect(Parser._checked);
			this.Block_NT();
		} else if (this.la.kind == Parser._unchecked && this.Peek(1).kind == Parser._lbrace) {
			this.Expect(Parser._unchecked);
			this.Block_NT();
		} else if (this.StartOf(21 /* nt   StatementExpression */)) {
			this.StatementExpression_NT();
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._if)) {
			this.Get();
			this.Expect(Parser._lpar);
			this.Expression_NT();
			this.Expect(Parser._rpar);
			this.EmbeddedStatement_NT();
			if (this.isKind(this.la, Parser._else)) {
				this.Get();
				this.EmbeddedStatement_NT();
			}
		} else if (this.isKind(this.la, Parser._switch)) {
			this.Get();
			this.Expect(Parser._lpar);
			this.Expression_NT();
			this.Expect(Parser._rpar);
			this.Expect(Parser._lbrace);
			while (this.isKind(this.la, Parser._case) || this.isKind(this.la, Parser._default)) {
				this.SwitchSection_NT();
			}
			this.Expect(Parser._rbrace);
		} else if (this.isKind(this.la, Parser._while)) {
			this.Get();
			this.Expect(Parser._lpar);
			this.Expression_NT();
			this.Expect(Parser._rpar);
			this.EmbeddedStatement_NT();
		} else if (this.isKind(this.la, Parser._do)) {
			this.Get();
			this.EmbeddedStatement_NT();
			this.Expect(Parser._while);
			this.Expect(Parser._lpar);
			this.Expression_NT();
			this.Expect(Parser._rpar);
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._for)) {
			this.Get();
			this.Expect(Parser._lpar);
			if (this.StartOf(24 /* nt   ForInitializer */)) {
				this.ForInitializer_NT();
			}
			this.Expect(Parser._scolon);
			if (this.StartOf(21 /* nt   Expression */)) {
				this.Expression_NT();
			}
			this.Expect(Parser._scolon);
			if (this.StartOf(21 /* nt   ForIterator */)) {
				this.ForIterator_NT();
			}
			this.Expect(Parser._rpar);
			this.EmbeddedStatement_NT();
		} else if (this.isKind(this.la, Parser._foreach)) {
			this.Get();
            this.t.val = "for";
			this.Expect(Parser._lpar);
			type = this.Type_NT(false);
			this.Expect(Parser._ident);
			this.t.spaceBefore = ""; this.t.val = "let " + this.t.val; // + " : " + saved_type;
			this.Expect(Parser._in);
            this.t.val = "of";
			this.Expression_NT();
			this.Expect(Parser._rpar);
			this.EmbeddedStatement_NT();
		} else if (this.isKind(this.la, Parser._break)) {
			this.Get();
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._continue)) {
			this.Get();
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._goto)) {
			this.Get();
			if (this.isKind(this.la, Parser._ident)) {
				this.Get();
			} else if (this.isKind(this.la, Parser._case)) {
				this.Get();
				this.Expression_NT();
			} else if (this.isKind(this.la, Parser._default)) {
				this.Get();
			} else this.SynErr(174);
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._return)) {
			this.Get();
			if (this.StartOf(21 /* nt   Expression */)) {
				this.Expression_NT();
			}
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._throw)) {
			this.Get();
			if (this.StartOf(21 /* nt   Expression */)) {
				this.Expression_NT();
			}
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._try)) {
			this.Get();
			this.Block_NT();
			if (this.isKind(this.la, Parser._catch)) {
				this.CatchClauses_NT();
				if (this.isKind(this.la, Parser._finally)) {
					this.Get();
					this.Block_NT();
				}
			} else if (this.isKind(this.la, Parser._finally)) {
				this.Get();
				this.Block_NT();
			} else this.SynErr(175);
		} else if (this.isKind(this.la, Parser._lock)) {
			this.Get();
			this.Expect(Parser._lpar);
			this.Expression_NT();
			this.Expect(Parser._rpar);
			this.EmbeddedStatement_NT();
		} else if (this.isKind(this.la, Parser._usingKW)) {
			this.Get();
			this.Expect(Parser._lpar);
			this.ResourceAcquisition_NT();
			this.Expect(Parser._rpar);
			this.EmbeddedStatement_NT();
		} else if (this.isKind(this.la, 120 /* "yield" */)) {
			this.Get();
			if (this.isKind(this.la, Parser._return)) {
				this.Get();
				this.Expression_NT();
			} else if (this.isKind(this.la, Parser._break)) {
				this.Get();
			} else this.SynErr(176);
			this.Expect(Parser._scolon);
		} else if (this.isKind(this.la, Parser._unsafe)) {
			this.Get();
			this.Block_NT();
		} else if (this.isKind(this.la, Parser._fixed)) {
			this.Get();
			this.Expect(Parser._lpar);
			type = this.Type_NT(false);
			if (type != TypeKind.pointer) Error("can only fix pointer types"); 
			this.Expect(Parser._ident);
			this.Expect(Parser._assgn);
			this.Expression_NT();
			while (this.isKind(this.la, Parser._comma)) {
				this.Get();
				this.Expect(Parser._ident);
				this.Expect(Parser._assgn);
				this.Expression_NT();
			}
			this.Expect(Parser._rpar);
			this.EmbeddedStatement_NT();
		} else this.SynErr(177);
	}

	private StatementExpression_NT() : void {
		let isAssignment : bool = Parser.assnStartOp.Get(this.la.kind) || this.IsTypeCast(); 
		this.Unary_NT();
		if (this.StartOf(25 /* nt   AssignmentOperator */)) {
			this.AssignmentOperator_NT();
			this.Expression_NT();
		} else if (this.isKind(this.la, Parser._comma) || this.isKind(this.la, Parser._rpar) || this.isKind(this.la, Parser._scolon)) {
			if (isAssignment) Error("error in assignment."); 
		} else this.SynErr(178);
	}

	private SwitchSection_NT() : void {
		this.SwitchLabel_NT();
		while (this.la.kind == Parser._case || (this.la.kind == Parser._default && this.Peek(1).kind == Parser._colon)) {
			this.SwitchLabel_NT();
		}
		this.Statement_NT();
		while (this.IsNoSwitchLabelOrRBrace()) {
			this.Statement_NT();
		}
	}

	private ForInitializer_NT() : void {
		if (this.IsLocalVarDecl()) {
			this.LocalVariableDeclaration_NT();
		} else if (this.StartOf(21 /* nt   StatementExpression */)) {
			this.StatementExpression_NT();
			while (this.isKind(this.la, Parser._comma)) {
				this.Get();
				this.StatementExpression_NT();
			}
		} else this.SynErr(179);
	}

	private ForIterator_NT() : void {
		this.StatementExpression_NT();
		while (this.isKind(this.la, Parser._comma)) {
			this.Get();
			this.StatementExpression_NT();
		}
	}

	private CatchClauses_NT() : void {
		this.Expect(Parser._catch);
		if (this.isKind(this.la, Parser._lbrace)) {
			this.Block_NT();
		} else if (this.isKind(this.la, Parser._lpar)) {
			this.Get();
			this.ClassType_NT();
			if (this.isKind(this.la, Parser._ident)) {
				this.Get();
			}
			this.Expect(Parser._rpar);
			this.Block_NT();
			if (this.isKind(this.la, Parser._catch)) {
				this.CatchClauses_NT();
			}
		} else this.SynErr(180);
	}

	private ResourceAcquisition_NT() : void {
		if (this.IsLocalVarDecl()) {
			this.LocalVariableDeclaration_NT();
		} else if (this.StartOf(21 /* nt   Expression */)) {
			this.Expression_NT();
		} else this.SynErr(181);
	}

	private Unary_NT() : void {
		let dummy : TypeKind; 
		while (Parser.unaryHead.Get(this.la.kind) || this.IsTypeCast()) {
			switch (this.la.kind) {
			case Parser._plus: {
				this.Get();
				break;
			}
			case Parser._minus: {
				this.Get();
				break;
			}
			case Parser._not: {
				this.Get();
				break;
			}
			case Parser._tilde: {
				this.Get();
				break;
			}
			case Parser._inc: {
				this.Get();
				break;
			}
			case Parser._dec: {
				this.Get();
				break;
			}
			case Parser._times: {
				this.Get();
				break;
			}
			case Parser._and: {
				this.Get();
				break;
			}
			case Parser._lpar: {
				this.Get();
				dummy = this.Type_NT(false);
				this.Expect(Parser._rpar);
				break;
			}
			default: this.SynErr(182); break;
			}
		}
		this.Primary_NT();
	}

	private AssignmentOperator_NT() : void {
		switch (this.la.kind) {
		case Parser._assgn: {
			this.Get();
			break;
		}
		case Parser._plusassgn: {
			this.Get();
			break;
		}
		case Parser._minusassgn: {
			this.Get();
			break;
		}
		case Parser._timesassgn: {
			this.Get();
			break;
		}
		case Parser._divassgn: {
			this.Get();
			break;
		}
		case Parser._modassgn: {
			this.Get();
			break;
		}
		case Parser._andassgn: {
			this.Get();
			break;
		}
		case Parser._orassgn: {
			this.Get();
			break;
		}
		case Parser._xorassgn: {
			this.Get();
			break;
		}
		case Parser._lshassgn: {
			this.Get();
			break;
		}
		case Parser._gt: {
			this.Get();
			let pos : int = this.t.pos; 
			this.Expect(Parser._gteq);
			if (pos+1 < this.t.pos) Error("no whitespace allowed in right shift assignment"); 
			break;
		}
		default: this.SynErr(183); break;
		}
	}

	private SwitchLabel_NT() : void {
		if (this.isKind(this.la, Parser._case)) {
			this.Get();
			this.Expression_NT();
			this.Expect(Parser._colon);
		} else if (this.isKind(this.la, Parser._default)) {
			this.Get();
			this.Expect(Parser._colon);
		} else this.SynErr(184);
	}

	private NullCoalescingExpr_NT() : void {
		this.OrExpr_NT();
		while (this.isKind(this.la, 121 /* "??" */)) {
			this.Get();
			this.Unary_NT();
			this.OrExpr_NT();
		}
	}

	private OrExpr_NT() : void {
		this.AndExpr_NT();
		while (this.isKind(this.la, 122 /* "||" */)) {
			this.Get();
			this.Unary_NT();
			this.AndExpr_NT();
		}
	}

	private AndExpr_NT() : void {
		this.BitOrExpr_NT();
		while (this.isKind(this.la, 123 /* "&&" */)) {
			this.Get();
			this.Unary_NT();
			this.BitOrExpr_NT();
		}
	}

	private BitOrExpr_NT() : void {
		this.BitXorExpr_NT();
		while (this.isKind(this.la, 124 /* "|" */)) {
			this.Get();
			this.Unary_NT();
			this.BitXorExpr_NT();
		}
	}

	private BitXorExpr_NT() : void {
		this.BitAndExpr_NT();
		while (this.isKind(this.la, 125 /* "^" */)) {
			this.Get();
			this.Unary_NT();
			this.BitAndExpr_NT();
		}
	}

	private BitAndExpr_NT() : void {
		this.EqlExpr_NT();
		while (this.isKind(this.la, Parser._and)) {
			this.Get();
			this.Unary_NT();
			this.EqlExpr_NT();
		}
	}

	private EqlExpr_NT() : void {
		this.RelExpr_NT();
		while (this.isKind(this.la, Parser._eq) || this.isKind(this.la, Parser._neq)) {
			if (this.isKind(this.la, Parser._neq)) {
				this.Get();
			} else {
				this.Get();
			}
			this.Unary_NT();
			this.RelExpr_NT();
		}
	}

	private RelExpr_NT() : void {
		this.ShiftExpr_NT();
		while (this.StartOf(26 /* alt   */)) {
			if (this.StartOf(27 /* alt   */)) {
				if (this.isKind(this.la, Parser._lt)) {
					this.Get();
				} else if (this.isKind(this.la, Parser._gt)) {
					this.Get();
				} else if (this.isKind(this.la, 126 /* "<=" */)) {
					this.Get();
				} else {
					this.Get();
				}
				this.Unary_NT();
				this.ShiftExpr_NT();
			} else {
				if (this.isKind(this.la, Parser._is)) {
					this.Get();
				} else {
					this.Get();
				}
				this.ResolvedType_NT();
			}
		}
	}

	private ShiftExpr_NT() : void {
		this.AddExpr_NT();
		while (this.IsShift()) {
			if (this.isKind(this.la, Parser._ltlt)) {
				this.Get();
			} else if (this.isKind(this.la, Parser._gt)) {
				this.Get();
				this.Expect(Parser._gt);
			} else this.SynErr(185);
			this.Unary_NT();
			this.AddExpr_NT();
		}
	}

	private AddExpr_NT() : void {
		this.MulExpr_NT();
		while (this.isKind(this.la, Parser._minus) || this.isKind(this.la, Parser._plus)) {
			if (this.isKind(this.la, Parser._plus)) {
				this.Get();
			} else {
				this.Get();
			}
			this.Unary_NT();
			this.MulExpr_NT();
		}
	}

	private MulExpr_NT() : void {
		while (this.isKind(this.la, Parser._times) || this.isKind(this.la, 127 /* "/" */) || this.isKind(this.la, 128 /* "%" */)) {
			if (this.isKind(this.la, Parser._times)) {
				this.Get();
			} else if (this.isKind(this.la, 127 /* "/" */)) {
				this.Get();
			} else {
				this.Get();
			}
			this.Unary_NT();
		}
	}

	private Primary_NT() : void {
		let type : TypeKind; let isArrayCreation : bool = false; 
		switch (this.la.kind) {
		case Parser._intCon: case Parser._realCon: case Parser._charCon: case Parser._stringCon: case Parser._false: case Parser._null: case Parser._true: {
			this.Literal_NT();
			break;
		}
		case Parser._lpar: {
			this.Get();
			this.Expression_NT();
			this.Expect(Parser._rpar);
			break;
		}
		case Parser._bool: case Parser._byte: case Parser._char: case Parser._decimal: case Parser._double: case Parser._float: case Parser._int: case Parser._long: case Parser._object: case Parser._sbyte: case Parser._short: case Parser._string: case Parser._uint: case Parser._ulong: case Parser._ushort: {
			switch (this.la.kind) {
			case Parser._bool: {
				this.Get();
				break;
			}
			case Parser._byte: {
				this.Get();
				break;
			}
			case Parser._char: {
				this.Get();
				break;
			}
			case Parser._decimal: {
				this.Get();
				break;
			}
			case Parser._double: {
				this.Get();
				break;
			}
			case Parser._float: {
				this.Get();
				break;
			}
			case Parser._int: {
				this.Get();
				break;
			}
			case Parser._long: {
				this.Get();
				break;
			}
			case Parser._object: {
				this.Get();
				break;
			}
			case Parser._sbyte: {
				this.Get();
				break;
			}
			case Parser._short: {
				this.Get();
				break;
			}
			case Parser._string: {
				this.Get();
				break;
			}
			case Parser._uint: {
				this.Get();
				break;
			}
			case Parser._ulong: {
				this.Get();
				break;
			}
			case Parser._ushort: {
				this.Get();
				break;
			}
			}
			this.Expect(Parser._dot);
			this.Expect(Parser._ident);
			if (this.IsGeneric()) {
				this.TypeArgumentList_NT();
			}
			break;
		}
		case Parser._ident: {
			this.Get();
			if(this.classMemberNames.hasOwnProperty(this.t.val) && !this.classMemberFuncParamNames.hasOwnProperty(this.t.val))
            this.t.val = "this." + this.t.val;
			if (this.isKind(this.la, Parser._dblcolon)) {
				this.Get();
				this.Expect(Parser._ident);
				if (this.isKind(this.la, Parser._lt)) {
					this.TypeArgumentList_NT();
				}
				this.Expect(Parser._dot);
				this.Expect(Parser._ident);
			}
			if (this.IsGeneric()) {
				this.TypeArgumentList_NT();
			}
			break;
		}
		case Parser._this: {
			this.Get();
			break;
		}
		case Parser._base: {
			this.Get();
            this.t.val = "super";
			if (this.isKind(this.la, Parser._dot)) {
				this.Get();
				this.Expect(Parser._ident);
				if (this.IsGeneric()) {
					this.TypeArgumentList_NT();
				}
			} else if (this.isKind(this.la, Parser._lbrack)) {
				this.Get();
				this.Expression_NT();
				while (this.isKind(this.la, Parser._comma)) {
					this.Get();
					this.Expression_NT();
				}
				this.Expect(Parser._rbrack);
			} else this.SynErr(186);
			break;
		}
		case Parser._new: {
			this.Get();
			type = this.Type_NT(false);
			if (this.isKind(this.la, Parser._lpar)) {
				this.Get();
				if (this.StartOf(15 /* nt   Argument */)) {
					this.Argument_NT();
					while (this.isKind(this.la, Parser._comma)) {
						this.Get();
						this.Argument_NT();
					}
				}
				this.Expect(Parser._rpar);
			} else if (this.isKind(this.la, Parser._lbrack)) {
				this.Get();
				this.Expression_NT();
				while (this.isKind(this.la, Parser._comma)) {
					this.Get();
					this.Expression_NT();
				}
				this.Expect(Parser._rbrack);
				while (this.IsDims()) {
					this.Expect(Parser._lbrack);
					while (this.isKind(this.la, Parser._comma)) {
						this.Get();
					}
					this.Expect(Parser._rbrack);
				}
				if (this.isKind(this.la, Parser._lbrace)) {
					this.ArrayInitializer_NT();
				}
				isArrayCreation = true; 
			} else if (this.isKind(this.la, Parser._lbrace)) {
				this.ArrayInitializer_NT();
				if (type != TypeKind.array) Error("array type expected");
				isArrayCreation = true;
				
			} else this.SynErr(187);
			break;
		}
		case Parser._typeof: {
			this.Get();
			this.Expect(Parser._lpar);
			type = this.Type_NT(true);
			this.Expect(Parser._rpar);
			break;
		}
		case Parser._checked: {
			this.Get();
			this.Expect(Parser._lpar);
			this.Expression_NT();
			this.Expect(Parser._rpar);
			break;
		}
		case Parser._unchecked: {
			this.Get();
			this.Expect(Parser._lpar);
			this.Expression_NT();
			this.Expect(Parser._rpar);
			break;
		}
		case Parser._default: {
			this.Get();
			this.Expect(Parser._lpar);
			this.Primary_NT();
			this.Expect(Parser._rpar);
			break;
		}
		case Parser._delegate: {
			this.Get();
			if (this.isKind(this.la, Parser._lpar)) {
				this.Get();
				if (this.StartOf(13 /* nt   AnonymousMethodParameter */)) {
					this.AnonymousMethodParameter_NT();
					while (this.isKind(this.la, Parser._comma)) {
						this.Get();
						this.AnonymousMethodParameter_NT();
					}
				}
				this.Expect(Parser._rpar);
			}
			this.Block_NT();
			break;
		}
		case Parser._sizeof: {
			this.Get();
			this.Expect(Parser._lpar);
			type = this.Type_NT(false);
			this.Expect(Parser._rpar);
			break;
		}
		default: this.SynErr(188); break;
		}
		while (this.StartOf(28 /* alt   */)) {
			switch (this.la.kind) {
			case Parser._inc: {
				this.Get();
				break;
			}
			case Parser._dec: {
				this.Get();
				break;
			}
			case 129 /* "->" */: {
				this.Get();
				this.Expect(Parser._ident);
				if (this.IsGeneric()) {
					this.TypeArgumentList_NT();
				}
				break;
			}
			case Parser._dot: {
				this.Get();
				this.Expect(Parser._ident);
				if (this.IsGeneric()) {
					this.TypeArgumentList_NT();
				}
				break;
			}
			case Parser._lpar: {
				this.Get();
				if (this.StartOf(15 /* nt   Argument */)) {
					this.Argument_NT();
					while (this.isKind(this.la, Parser._comma)) {
						this.Get();
						this.Argument_NT();
					}
				}
				this.Expect(Parser._rpar);
				break;
			}
			case Parser._lbrack: {
				if (isArrayCreation) Error("element access not allow on array creation"); 
				this.Get();
				this.Expression_NT();
				while (this.isKind(this.la, Parser._comma)) {
					this.Get();
					this.Expression_NT();
				}
				this.Expect(Parser._rbrack);
				break;
			}
			}
		}
	}

	private Literal_NT() : void {
		switch (this.la.kind) {
		case Parser._intCon: {
			this.Get();
			break;
		}
		case Parser._realCon: {
			this.Get();
			break;
		}
		case Parser._charCon: {
			this.Get();
			let ch : char = this.t.val.charCodeAt(1);
			if(ch == 92 /*'\\'*/) {
				ch = this.t.val.charCodeAt(2);
				switch (ch)
				{
					case 92 /*'\\'*/:  this.t.val = "92 /*'\\\\'*/"; break;
					case 39 /*'\''*/:  this.t.val = "39 /*'\\''*/"; break;
					case 34 /*'\"'*/:  this.t.val = "34 /*'\\\"'*/"; break;
					case 114 /*'r'*/:  this.t.val = "13 /*'\\r'*/"; break;
					case 110 /*'n'*/:  this.t.val = "10 /*'\\n'*/"; break;
					case 116 /*'t'*/:  this.t.val = "9 /*'\\t'*/"; break;
					case 48 /*'0'*/:   this.t.val = "0 /*'\\0'*/"; break;
					case 97 /*'a'*/:   this.t.val = "7 /*'\\a'*/"; break;
					case 98 /*'b'*/:   this.t.val = "8 /*'\\b'*/"; break;
					case 102 /*'f'*/:  this.t.val = "12 /*'\\f'*/"; break;
					case 118 /*'v'*/:  this.t.val = "11 /*'\\v'*/"; break;
				}
			}
			else this.t.val =  ch.toString() + " /*" + this.t.val + "*/";
			break;
		}
		case Parser._stringCon: {
			this.Get();
			break;
		}
		case Parser._true: {
			this.Get();
			break;
		}
		case Parser._false: {
			this.Get();
			break;
		}
		case Parser._null: {
			this.Get();
			break;
		}
		default: this.SynErr(189); break;
		}
	}

	private AnonymousMethodParameter_NT() : void {
		let dummy : TypeKind; 
		if (this.isKind(this.la, Parser._xout) || this.isKind(this.la, Parser._ref)) {
			if (this.isKind(this.la, Parser._ref)) {
				this.Get();
			} else {
				this.Get();
			}
		}
		dummy = this.Type_NT(false);
		this.Expect(Parser._ident);
	}



	public Parse() : void {
		this.la = new Token();
		this.la.val = "";
		this.Get();
		this.CS2_NT();
		this.Expect(0);

	}

	// a token's base type
	public static readonly tBase : int[] = [

		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
		-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    ];

	static readonly set : bool[][] = [
		[true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,true,false, false,false,false,false, false,false,false,false, true,false,false,false, false,true,false,false, false,true,false,false, true,false,false,false, false,false,false,false, false,false,false,false, true,true,false,false, false,true,true,false, false,false,false,true, false,true,true,true, true,false,false,false, true,false,false,false, true,false,true,false, false,false,false,false, false,false,false,false, true,false,false,true, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,true,false, false,false,false,false, false,false,false,false, true,false,false,false, false,true,false,false, false,true,false,false, true,false,false,false, false,false,false,false, false,false,false,false, true,true,false,false, false,false,true,false, false,false,false,true, false,true,true,true, true,false,false,false, true,false,false,false, true,false,true,false, false,false,false,false, false,false,false,false, true,false,false,true, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,true, true,true,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,true,false, false,false,false,true, false,true,true,true, true,false,false,false, true,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, true,false,false,true, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,false,false, false,false,false,false, false,true,false,true, false,false,true,false, false,false,false,true, false,false,false,true, false,false,true,false, false,false,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,true,false, true,false,false,false, false,false,false,false, false,false,false,true, false,true,false,false, false,true,false,false, false,false,false,false, false,true,true,false, false,true,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,false,false, false,false,false,false, false,true,false,true, false,false,true,false, false,false,false,true, false,false,false,true, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,false,false, true,false,true,false, true,false,false,false, false,true,false,true, false,true,false,false, false,true,false,false, false,false,false,false, false,true,true,false, false,true,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,false,false, false,false,true,false, false,true,false,true, false,false,true,false, true,true,false,true, false,true,false,true, false,true,true,true, true,false,false,false, true,false,false,false, false,true,false,true, true,true,false,false, true,false,true,false, true,false,false,true, false,true,true,true, true,false,false,true, true,true,false,false, true,true,true,false, false,false,false,false, false,true,true,false, true,true,false,true, true,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,false,false, false,false,true,false, false,true,false,true, false,false,true,false, true,true,false,true, false,true,false,true, false,true,true,true, true,false,false,false, true,false,false,false, false,true,false,true, true,true,false,false, true,false,true,false, true,false,false,true, false,true,true,true, true,false,false,true, true,true,false,false, true,true,true,false, false,false,false,false, false,true,true,false, true,true,false,true, true,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,false,false, false,false,false,false, false,true,false,true, false,false,true,false, false,false,false,true, false,false,false,true, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,false,false, true,false,false,false, false,false,false,false, false,false,false,true, false,true,false,false, false,true,false,false, false,false,false,false, false,true,true,false, false,true,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,false,false, false,true,false,true, false,false,true,false, false,false,false,true, false,false,false,true, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,true,false,false, false,false,false,false, false,false,false,false, false,true,true,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,false,false, false,false,false,false, false,true,false,true, false,false,true,false, false,false,false,true, false,false,false,true, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,false,false, true,false,true,false, false,false,false,false, false,true,false,true, false,true,false,false, false,true,false,false, false,false,false,false, false,true,true,false, false,true,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,false,false, false,false,false,false, false,true,false,true, false,false,true,false, true,true,false,true, false,true,false,true, false,true,true,true, false,false,false,false, true,false,false,false, false,true,false,true, true,false,false,false, true,false,false,false, true,false,false,false, false,false,false,false, false,false,false,true, false,true,false,false, false,true,true,false, false,false,false,false, false,true,true,false, false,true,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,true,true, true,true,false,false, true,true,false,true, false,false,true,true, false,false,false,true, true,true,false,true, false,false,false,false, false,true,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,true,true, true,false,true,false, false,false,false,false, false,true,false,true, false,true,true,false, false,true,false,false, true,false,true,false, true,true,true,true, false,true,false,false, false,false,false,true, false,false,false,false, true,false,false,false, false,false,false,true, false,false,true,false, false,false,true,false, false,false,true,false, true,false,false,false, false,false,false,true, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,false,false, false,true,false,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,true,true, true,true,false,false, true,true,true,true, false,false,true,true, false,true,true,true, true,true,true,true, false,false,false,false, false,true,false,true, true,true,true,true, true,false,false,true, false,false,false,true, true,false,true,true, true,false,false,false, false,false,false,false, false,false,true,true, false,true,true,false, false,true,false,true, true,true,true,true, true,true,true,true, true,true,true,false, true,false,true,true, false,false,false,false, true,false,false,false, false,false,false,true, true,false,true,false, false,false,true,false, false,false,true,false, true,false,false,false, false,false,true,true, true,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,true,true, false,false,false,false, true,true,true,false, false,false,false,false, true,true,true,false, false,true,false,false, true,false,true,true, true,true,true,false, true,false,false,false, false,true,true,true, true,true,true,true, true,false,false,false],
		[false,true,false,false, false,false,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,true,false, false,false,false,true, false,true,true,true, true,false,false,false, true,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, true,false,false,true, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,true,true, true,true,false,false, true,true,false,true, false,false,true,true, false,false,false,true, true,true,false,true, false,false,false,false, false,true,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,true,true, true,false,false,false, false,false,false,false, false,false,false,true, false,true,true,false, false,true,false,false, true,false,true,false, true,true,true,true, false,true,false,false, false,false,false,true, false,false,false,false, true,false,false,false, false,false,false,true, true,false,true,false, false,false,true,false, false,false,true,false, true,false,false,false, false,false,false,true, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,true,true, true,true,false,false, true,true,false,true, false,false,true,true, false,false,false,true, true,true,false,true, false,false,false,false, false,true,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,true,true, true,false,false,false, false,false,false,false, false,false,false,true, false,true,true,false, false,true,false,false, true,false,true,false, true,true,true,true, false,true,false,false, false,false,false,true, false,false,false,false, true,false,false,false, false,false,false,true, false,false,true,false, false,false,true,false, false,false,true,false, true,false,false,false, false,false,false,true, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,false,false, false,false,false,true, false,false,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,true, false,true,false,false, false,false,false,false, false,false,false,false, false,true,true,false, false,true,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,true,true, true,true,false,false, true,true,true,true, false,false,true,true, false,false,true,true, true,true,true,true, false,false,false,false, false,true,false,true, true,true,true,true, true,false,false,true, false,false,false,true, true,false,true,true, true,false,false,false, false,false,false,false, false,false,true,true, false,true,true,false, false,true,false,true, true,true,true,true, true,true,true,true, true,true,true,false, false,false,true,true, false,false,false,false, true,false,false,false, false,false,false,true, true,false,true,false, false,false,true,false, false,false,true,false, true,false,false,false, false,false,true,true, true,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false],
		[false,true,true,true, true,true,false,false, true,true,false,true, false,false,true,true, false,false,false,true, true,true,false,true, false,false,false,false, false,true,false,false, true,false,false,false, false,false,false,true, false,false,false,false, true,false,true,true, true,false,false,false, false,false,false,false, false,false,false,true, false,true,true,false, false,true,false,false, true,false,true,false, true,true,true,true, false,true,false,false, true,false,false,true, false,false,false,false, true,false,false,false, false,false,false,true, false,false,true,false, false,false,true,false, false,false,true,false, true,false,false,false, false,false,false,true, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,true,false,false, false,true,false,false, false,true,false,false, false,false,false,true, false,false,false,true, true,false,false,true, false,true,false,false, false,false,false,false, false,true,true,false, false,false,false,false, false,false,false,false, false,false,false,false],
		[false,false,false,false, false,false,false,true, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,true,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,true,false, false,false,false,false],
		[false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,true,false, false,false,false,false, true,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,true,false, false,false,false,false],
		[false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, true,false,true,false, false,false,false,true, false,true,true,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,false,false,false, false,true,false,false]

    ];
/*
	public void CheckDeclared(errors : Errors) {
		let list : Array<Token>  = undeclaredTokens.Peek();
		for(Token t of list) {
			let msg : string  = string.Format(Parser.MissingSymbol, Parser.tName[this.t.kind], this.t.val, this.name);
			errors.SemErr(this.t.line, this.t.col, msg);
		}
	}
*/

/*#if PARSER_WITH_AST
	public ast_root : SynTree;
	private ast_stack : Stack ;

	public AstAddTerminal() : void {
        let st : SynTree = new SynTree( this.t );
        ((SynTree)(this.ast_stack.Peek())).children.Add(st);
	}

	public AstAddNonTerminal(kind : int, nt_name : string, line : int) : bool {
        let ntTok : Token  = new Token();
        ntTok.kind = kind;
        ntTok.line = line;
        ntTok.val = nt_name;
        let st : SynTree = new SynTree( ntTok );
        ((SynTree)(this.ast_stack.Peek())).children.Add(st);
        this.ast_stack.Push(st);
        return true;
	}

	public AstPopNonTerminal() : void {
        this.ast_stack.Pop();
	}
//#endif*/

} // end Parser


class Errors {
    public  count : int = 0;                                    // number of errors detected
    //public  errorStream : StreamWriter; //.IO.TextWriter = Console.Out;   // error messages go to this stream
    //public  errMsgFormat : string = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
    public  errMsgFormat : string = "%s:%d:%d %s %s"; // 0=line, 1=column, 2=text
    public  fileName : string = "grammar"; // 0=line, 1=column, 2=text

    constructor(fileName : string) {
        this.fileName = fileName;
    }

	public /*virtual*/  SynErr ( line : int,  col : int,  n : int) : void {
		let s : string;
		switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "ident expected"; break;
			case 2: s = "intCon expected"; break;
			case 3: s = "realCon expected"; break;
			case 4: s = "charCon expected"; break;
			case 5: s = "stringCon expected"; break;
			case 6: s = "abstract expected"; break;
			case 7: s = "as expected"; break;
			case 8: s = "base expected"; break;
			case 9: s = "bool expected"; break;
			case 10: s = "break expected"; break;
			case 11: s = "byte expected"; break;
			case 12: s = "case expected"; break;
			case 13: s = "catch expected"; break;
			case 14: s = "char expected"; break;
			case 15: s = "checked expected"; break;
			case 16: s = "class expected"; break;
			case 17: s = "const expected"; break;
			case 18: s = "continue expected"; break;
			case 19: s = "decimal expected"; break;
			case 20: s = "default expected"; break;
			case 21: s = "delegate expected"; break;
			case 22: s = "do expected"; break;
			case 23: s = "double expected"; break;
			case 24: s = "else expected"; break;
			case 25: s = "enum expected"; break;
			case 26: s = "event expected"; break;
			case 27: s = "explicit expected"; break;
			case 28: s = "extern expected"; break;
			case 29: s = "false expected"; break;
			case 30: s = "finally expected"; break;
			case 31: s = "fixed expected"; break;
			case 32: s = "float expected"; break;
			case 33: s = "for expected"; break;
			case 34: s = "foreach expected"; break;
			case 35: s = "goto expected"; break;
			case 36: s = "if expected"; break;
			case 37: s = "implicit expected"; break;
			case 38: s = "in expected"; break;
			case 39: s = "int expected"; break;
			case 40: s = "interface expected"; break;
			case 41: s = "internal expected"; break;
			case 42: s = "is expected"; break;
			case 43: s = "lock expected"; break;
			case 44: s = "long expected"; break;
			case 45: s = "namespace expected"; break;
			case 46: s = "new expected"; break;
			case 47: s = "null expected"; break;
			case 48: s = "object expected"; break;
			case 49: s = "operator expected"; break;
			case 50: s = "_at_out expected"; break;
			case 51: s = "override expected"; break;
			case 52: s = "params expected"; break;
			case 53: s = "private expected"; break;
			case 54: s = "protected expected"; break;
			case 55: s = "public expected"; break;
			case 56: s = "readonly expected"; break;
			case 57: s = "ref expected"; break;
			case 58: s = "return expected"; break;
			case 59: s = "sbyte expected"; break;
			case 60: s = "sealed expected"; break;
			case 61: s = "short expected"; break;
			case 62: s = "sizeof expected"; break;
			case 63: s = "stackalloc expected"; break;
			case 64: s = "static expected"; break;
			case 65: s = "string expected"; break;
			case 66: s = "struct expected"; break;
			case 67: s = "switch expected"; break;
			case 68: s = "this expected"; break;
			case 69: s = "throw expected"; break;
			case 70: s = "true expected"; break;
			case 71: s = "try expected"; break;
			case 72: s = "typeof expected"; break;
			case 73: s = "uint expected"; break;
			case 74: s = "ulong expected"; break;
			case 75: s = "unchecked expected"; break;
			case 76: s = "unsafe expected"; break;
			case 77: s = "ushort expected"; break;
			case 78: s = "usingKW expected"; break;
			case 79: s = "virtual expected"; break;
			case 80: s = "void expected"; break;
			case 81: s = "volatile expected"; break;
			case 82: s = "while expected"; break;
			case 83: s = "and expected"; break;
			case 84: s = "andassgn expected"; break;
			case 85: s = "assgn expected"; break;
			case 86: s = "colon expected"; break;
			case 87: s = "comma expected"; break;
			case 88: s = "dec expected"; break;
			case 89: s = "divassgn expected"; break;
			case 90: s = "dot expected"; break;
			case 91: s = "dblcolon expected"; break;
			case 92: s = "eq expected"; break;
			case 93: s = "gt expected"; break;
			case 94: s = "gteq expected"; break;
			case 95: s = "inc expected"; break;
			case 96: s = "lbrace expected"; break;
			case 97: s = "lbrack expected"; break;
			case 98: s = "lpar expected"; break;
			case 99: s = "lshassgn expected"; break;
			case 100: s = "lt expected"; break;
			case 101: s = "ltlt expected"; break;
			case 102: s = "minus expected"; break;
			case 103: s = "minusassgn expected"; break;
			case 104: s = "modassgn expected"; break;
			case 105: s = "neq expected"; break;
			case 106: s = "not expected"; break;
			case 107: s = "orassgn expected"; break;
			case 108: s = "plus expected"; break;
			case 109: s = "plusassgn expected"; break;
			case 110: s = "question expected"; break;
			case 111: s = "rbrace expected"; break;
			case 112: s = "rbrack expected"; break;
			case 113: s = "rpar expected"; break;
			case 114: s = "scolon expected"; break;
			case 115: s = "tilde expected"; break;
			case 116: s = "times expected"; break;
			case 117: s = "timesassgn expected"; break;
			case 118: s = "_at_orassgn expected"; break;
			case 119: s = "\"partial\" expected"; break;
			case 120: s = "\"yield\" expected"; break;
			case 121: s = "\"??\" expected"; break;
			case 122: s = "\"||\" expected"; break;
			case 123: s = "\"&&\" expected"; break;
			case 124: s = "\"|\" expected"; break;
			case 125: s = "\"^\" expected"; break;
			case 126: s = "\"<=\" expected"; break;
			case 127: s = "\"/\" expected"; break;
			case 128: s = "\"%\" expected"; break;
			case 129: s = "\"->\" expected"; break;
			case 130: s = "??? expected"; break;
			case 131: s = "invalid NamespaceMemberDeclaration"; break;
			case 132: s = "invalid Attributes"; break;
			case 133: s = "invalid TypeDeclaration"; break;
			case 134: s = "invalid TypeDeclaration"; break;
			case 135: s = "invalid TypeParameterConstraintsClause"; break;
			case 136: s = "invalid InterfaceMemberDeclaration"; break;
			case 137: s = "invalid InterfaceMemberDeclaration"; break;
			case 138: s = "invalid InterfaceMemberDeclaration"; break;
			case 139: s = "invalid IntegralType"; break;
			case 140: s = "invalid Type"; break;
			case 141: s = "invalid FormalParameterList"; break;
			case 142: s = "invalid ClassType"; break;
			case 143: s = "invalid ClassMemberDeclaration"; break;
			case 144: s = "invalid ClassMemberDeclaration"; break;
			case 145: s = "invalid StructMemberDeclaration"; break;
			case 146: s = "invalid StructMemberDeclaration"; break;
			case 147: s = "invalid StructMemberDeclaration"; break;
			case 148: s = "invalid StructMemberDeclaration"; break;
			case 149: s = "invalid StructMemberDeclaration"; break;
			case 150: s = "invalid StructMemberDeclaration"; break;
			case 151: s = "invalid StructMemberDeclaration"; break;
			case 152: s = "invalid StructMemberDeclaration"; break;
			case 153: s = "invalid StructMemberDeclaration"; break;
			case 154: s = "invalid StructMemberDeclaration"; break;
			case 155: s = "invalid Expression"; break;
			case 156: s = "invalid EventAccessorDeclarations"; break;
			case 157: s = "invalid EventAccessorDeclarations"; break;
			case 158: s = "invalid OverloadableOp"; break;
			case 159: s = "invalid AccessorDeclarations"; break;
			case 160: s = "invalid AccessorDeclarations"; break;
			case 161: s = "invalid AccessorDeclarations"; break;
			case 162: s = "invalid AccessorDeclarations"; break;
			case 163: s = "invalid InterfaceAccessors"; break;
			case 164: s = "invalid InterfaceAccessors"; break;
			case 165: s = "invalid LocalVariableDeclarator"; break;
			case 166: s = "invalid VariableInitializer"; break;
			case 167: s = "invalid Keyword"; break;
			case 168: s = "invalid AttributeArguments"; break;
			case 169: s = "invalid PrimitiveType"; break;
			case 170: s = "invalid PointerOrArray"; break;
			case 171: s = "invalid ResolvedType"; break;
			case 172: s = "invalid InternalClassType"; break;
			case 173: s = "invalid Statement"; break;
			case 174: s = "invalid EmbeddedStatement"; break;
			case 175: s = "invalid EmbeddedStatement"; break;
			case 176: s = "invalid EmbeddedStatement"; break;
			case 177: s = "invalid EmbeddedStatement"; break;
			case 178: s = "invalid StatementExpression"; break;
			case 179: s = "invalid ForInitializer"; break;
			case 180: s = "invalid CatchClauses"; break;
			case 181: s = "invalid ResourceAcquisition"; break;
			case 182: s = "invalid Unary"; break;
			case 183: s = "invalid AssignmentOperator"; break;
			case 184: s = "invalid SwitchLabel"; break;
			case 185: s = "invalid ShiftExpr"; break;
			case 186: s = "invalid Primary"; break;
			case 187: s = "invalid Primary"; break;
			case 188: s = "invalid Primary"; break;
			case 189: s = "invalid Literal"; break;

			default: s = "error " + n; break;
		}
		//errorStream.WriteLine(errMsgFormat, line, col, s);
		console.log(this.fileName + ":" + line + ":" + col + " SynErr " + s);
		++this.count;
	}

    public /*virtual*/  SemErrLineColStr ( line : int,  col : int,  s : string) : void {
        //this.errorStream.WriteLine(this.errMsgFormat, line, col, s);
        console.log(this.fileName + ":" + line + ":" + col + " SemErr " + s);
        ++this.count;
    }

    public /*virtual*/  SemErr ( s : string) : void {
        //this.errorStream.WriteLine(s);
        console.log(s);
        ++this.count;
    }

    public /*virtual*/  Warning ( line : int,  col : int,  s : string) : void {
        //this.errorStream.WriteLine(this.errMsgFormat, line, col, s);
        console.log(this.fileName + ":" + line + ":" + col + " Warning " + s);
    }

    public /*virtual*/  WarningStr( s : string) : void {
        //this.errorStream.WriteLine(s);
        console.log(s);
    }
} // Errors


class FatalError /*extends Exception*/ {
    constructor( m : string)  {throw(m);}
}

class Symboltable {
	public name : string ;
	public strict : bool ;
	public ignoreCase : bool ;
	public predefined : {};

	constructor(name : string, ignoreCase : bool, strict : bool) {
		this.name = name;
		this.ignoreCase = ignoreCase;
		this.strict = strict;
	}

	public Add(t : Token) : bool {
		if(!this.predefined.hasOwnProperty(t.val)) {
			this.predefined[t.val] = true;
			return true;
		}
		return false;
	}

	public Use(t : Token) : bool {
		return this.predefined.hasOwnProperty(t.val);
	}
}

if (stdScriptArgs.length > 1) {
    let cs_fname = stdScriptArgs[1];
    let cs_source = std.loadFile(cs_fname);
    var scanner = new Scanner(cs_source, cs_fname);
    /*
    tok = scanner.Scan()
    while(tok.kind != Scanner.eofSym)
    {
        console.log(tok, tok.kind, tok.pos, tok.charPos, tok.col, tok.line, tok.val);
        tok = scanner.Scan();
    }
    */
    var parser = new Parser(scanner);
    parser.Parse();
    console.log("\n");
}
else {
    console.log("\n  usage: cs2ts cs_filename\n");
}
