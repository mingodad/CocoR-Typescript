/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/
-->begin

-->namespace

class Token {
    public  kind : int = 0;    // token kind
    public  pos : int = 0;     // token position in bytes in the source text (starting at 0)
    public  charPos : int = 0;  // token position in characters in the source text (starting at 0)
    public  col : int = 1;     // token column (starting at 1)
    public  line : int = 1;    // token line (starting at 1)
    public  val : string;  // token value
    public  next : Token | null = null;  // ML 2005-03-11 Tokens are kept in linked list
}

//-----------------------------------------------------------------------------------
// StringBuffer
//-----------------------------------------------------------------------------------
class Buffer {

    public static readonly EOF : int = Char_MaxValue + 1;
    buf : string;         // input buffer
    bufStart : int;       // position of first byte in buffer relative to input stream
    bufLen : int;         // length of buffer
    bufPos : int;         // current position in buffer

    public constructor (s : string) {
        this.buf = s;
        this.bufLen = s.length;
        this.bufStart = this.bufPos = 0;
    }

    public /*virtual*/ Read () : int {
        if (this.bufPos < this.bufLen) {
            return this.buf.charCodeAt(this.bufPos++);
        } else {
            return Buffer.EOF;
        }
    }

    public Peek () : int {
        const curPos : int = this.getPos();
        const ch : int = this.Read();
        this.setPos(curPos);
        return ch;
    }

    // beg .. begin, zero-based, inclusive, in byte
    // end .. end, zero-based, exclusive, in byte
    public GetString (beg : int, end : int) : string {
        return this.buf.slice(beg, end);
    }

    public getPos() : int { return this.bufPos + this.bufStart; }
    public setPos(value : int) : void {
        if (value < 0 || value > this.bufLen) {
            throw "buffer out of bounds access, position: " + value;
        }

        if (value >= this.bufStart && value < this.bufStart + this.bufLen) { // already in buffer
            this.bufPos = value - this.bufStart;
        } else {
            // set the position to the end of the file, Pos will return fileLen.
            this.bufPos = this.bufLen - this.bufStart;
        }
    }

}

//-----------------------------------------------------------------------------------
// Scanner
//-----------------------------------------------------------------------------------
class Scanner {
    static readonly  EOL : char = 10 /*'\n'*/;
    static readonly  eofSym : int = 0; /* pdt */
-->declarations

    public  buffer : Buffer; // scanner buffer

    private t : Token;          // current token
    private ch : int;           // current input character
    private pos : int;          // byte position of current character
    private charPos : int;      // position by unicode characters starting with 0
    private col : int;          // column number of current character
    private line : int;         // line number of current character
    private oldEols : int;      // EOLs that appeared in a comment;
    static  start : Array<int> = []; // maps first token character to start state

    private tokens : Token;     // list of tokens already peeked (first token is a dummy)
    private pt : Token;         // current peek token

    private tval : string; // text of current token
    private tlen : int;         // length of current token

    public parseFileName : string;
    public stateNo : int = 0;	// to user defined states

    private Init0() : void {
        Scanner.start = new Array<int>(128);
        for (let i=0; i<128; ++i) Scanner.start[i] = 0;
-->initialization
	}

    constructor(str : string , fileName : string) {
        this.parseFileName = fileName;
        this.buffer = new Buffer(str); // scanner buffer
        if(Scanner.start.length == 0) this.Init0();
        this.Init();
    }

    private  Init() : void {
        this.pos = -1; this.line = 1; this.col = 0; this.charPos = -1;
        this.oldEols = 0;
        this.NextCh();
        this.pt = this.tokens = new Token();  // first token is a dummy
    }

    private  NextCh() : void {
        if (this.oldEols > 0) { this.ch = Scanner.EOL; this.oldEols--; }
        else {
            this.pos = this.buffer.getPos();
            // buffer reads unicode chars, if UTF8 has been detected
            this.ch = this.buffer.Read(); this.col++; this.charPos++;
            // replace isolated '\r' by '\n' in order to make
            // eol handling uniform across Windows, Unix and Mac
            if (this.ch == 13 /*'\r'*/ && this.buffer.Peek() != Scanner.EOL /*'\n'*/) this.ch = Scanner.EOL;
            if (this.ch == Scanner.EOL) { this.line++; this.col = 0; }
        }
-->casing1
	}

    private AddCh() : void {
        if (this.ch != Buffer.EOF) {
            ++this.tlen;
            this.tval += String.fromCharCode(this.ch);
            this.NextCh();
        }
-->casing2
	}


-->comments

    private  CheckLiteral() : void {
-->literals
	}

	public NextToken() : Token {
		for(;;) {
			while (this.ch == 32 /*' '*/ ||
-->scan1
			)  this.NextCh();
-->scan2
			break;
		}
-->scan22
        let recKind : int = Scanner.noSym;
        let recEnd : int = this.pos;
        this.t = new Token();
        this.t.pos = this.pos; this.t.col = this.col; this.t.line = this.line; this.t.charPos = this.charPos;
        let state : int = (this.ch == Buffer.EOF) ? -1 : Scanner.start[this.ch];
        this.tlen = 0; this.tval = ""; this.AddCh();

        let loopState : bool = true;
        while(loopState) {
		switch (state) {
			case -1: { this.t.kind = Scanner.eofSym; loopState = false; break; } // NextCh already done
			case 0: {
				if (recKind != Scanner.noSym) {
					this.tlen = recEnd - this.t.pos;
					this.SetScannerBehindT();
				}
				this.t.kind = recKind; loopState = false; break;
			} // NextCh already done
-->scan3
		}
        }
        this.t.val = this.tval;
        return this.t;
    }

    private  SetScannerBehindT() : void {
        this.buffer.setPos(this.t.pos);
        this.NextCh();
        this.line = this.t.line; this.col = this.t.col; this.charPos = this.t.charPos;
        for ( let i : int = 0; i < this.tlen; i++) this.NextCh();
    }

    // get the next token (possibly a token already seen during peeking)
    public  Scan () : Token {
        if (this.tokens.next == null) {
            return this.NextToken();
        } else {
            this.pt = this.tokens = this.tokens.next;
            return this.tokens;
        }
    }

    // peek for the next token, ignore pragmas
    public  Peek () : Token {
        do {
            if (this.pt.next == null) {
                this.pt.next = this.NextToken();
            }
            this.pt = this.pt.next;
        } while (this.pt.kind > Scanner.maxT); // skip pragmas

        return this.pt;
    }

    // make sure that peeking starts at the current scan position
    public  ResetPeek () : void { this.pt = this.tokens; }

} // end Scanner

/*
let scanner : Scanner  = new Scanner(`let a : string = "str";`, "test.txt");
let tok : Token = scanner.Scan()
while(tok.kind != Scanner.eofSym)
{
	console.log(tok);
	tok = scanner.Scan();
}
*/
