/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

-->begin

-->namespace //For Javascript we do not emmit any namespace and use a fixed one
var CocoRJS;
(function (CocoRJS) {
Object.assign(this, CocoRJS); //concatenate then
var Token = /** @class */ (function () {
    function Token() {
        this.kind = 0; // token kind
        this.pos = 0; // token position in bytes in the source text (starting at 0)
        this.charPos = 0; // token position in characters in the source text (starting at 0)
        this.col = 1; // token column (starting at 1)
        this.line = 1; // token line (starting at 1)
        this.next = null; // ML 2005-03-11 Tokens are kept in linked list
    }
    return Token;
}());
CocoRJS.Token = Token;
//-----------------------------------------------------------------------------------
// StringBuffer
//-----------------------------------------------------------------------------------
var Buffer = /** @class */ (function () {
    function Buffer(s) {
        this.buf = s;
        this.bufLen = s.length;
        this.bufStart = this.bufPos = 0;
    }
    Buffer.prototype.Read = function () {
        if (this.bufPos < this.bufLen) {
            return this.buf.charCodeAt(this.bufPos++);
        }
        else {
            return Buffer.EOF;
        }
    };
    Buffer.prototype.Peek = function () {
        var curPos = this.getPos();
        var ch = this.Read();
        this.setPos(curPos);
        return ch;
    };
    // beg .. begin, zero-based, inclusive, in byte
    // end .. end, zero-based, exclusive, in byte
    Buffer.prototype.GetString = function (beg, end) {
        return this.buf.slice(beg, end);
    };
    Buffer.prototype.getPos = function () { return this.bufPos + this.bufStart; };
    Buffer.prototype.setPos = function (value) {
        if (value < 0 || value > this.bufLen) {
            throw "buffer out of bounds access, position: " + value;
        }
        if (value >= this.bufStart && value < this.bufStart + this.bufLen) { // already in buffer
            this.bufPos = value - this.bufStart;
        }
        else {
            // set the position to the end of the file, Pos will return fileLen.
            this.bufPos = this.bufLen - this.bufStart;
        }
    };
    Buffer.EOF = -1;
    return Buffer;
}());
CocoRJS.Buffer = Buffer;
//-----------------------------------------------------------------------------------
// Scanner
//-----------------------------------------------------------------------------------
var Scanner = /** @class */ (function () {
    function Scanner(str, fileName) {
        this.stateNo = 0; // to user defined states
        this.parseFileName = fileName;
        this.buffer = new Buffer(str); // scanner buffer
        if (Scanner.start.length == 0)
            this.Init0();
        this.Init();
    }

    Scanner.EOL = 10 /*'\n'*/;
    Scanner.eofSym = 0; /* pdt */
    Scanner.start = []; // maps first token character to start state
    -->declarations

    Scanner.prototype.Init0 = function () {
        Scanner.start = new Array(128);
        for (var i = 0; i < 128; ++i)
            Scanner.start[i] = 0;
-->initialization
    };
    Scanner.prototype.Init = function () {
        this.pos = -1;
        this.line = 1;
        this.col = 0;
        this.charPos = -1;
        this.oldEols = 0;
        this.NextCh();
        this.pt = this.tokens = new Token(); // first token is a dummy
    };
    Scanner.prototype.NextCh = function () {
        if (this.oldEols > 0) {
            this.ch = Scanner.EOL;
            this.oldEols--;
        }
        else {
            this.pos = this.buffer.getPos();
            // buffer reads unicode chars, if UTF8 has been detected
            this.ch = this.buffer.Read();
            this.col++;
            this.charPos++;
            // replace isolated '\r' by '\n' in order to make
            // eol handling uniform across Windows, Unix and Mac
            if (this.ch == 13 /*'\r'*/ && this.buffer.Peek() != Scanner.EOL /*'\n'*/)
                this.ch = Scanner.EOL;
            if (this.ch == Scanner.EOL) {
                this.line++;
                this.col = 0;
            }
        }
-->casing1
    };
    Scanner.prototype.AddCh = function () {
        if (this.ch != Buffer.EOF) {
            ++this.tlen;
            this.tval += String.fromCharCode(this.ch);
            this.NextCh();
        }
-->casing2
    };

-->comments

    Scanner.prototype.CheckLiteral = function () {
-->literals
    };
    Scanner.prototype.NextToken = function () {
        for (;;) {
            while (this.ch == 32 /*' '*/ ||
-->scan1
                )  this.NextCh();
-->scan2
            break;
        }
-->scan22
        var recKind = Scanner.noSym;
        var recEnd = this.pos;
        this.t = new Token();
        this.t.pos = this.pos;
        this.t.col = this.col;
        this.t.line = this.line;
        this.t.charPos = this.charPos;
        var state = (this.ch == Buffer.EOF) ? -1 : Scanner.start[this.ch];
        this.tlen = 0;
        this.tval = "";
        this.AddCh();
        loop: for (; ;) {
            switch (state) {
                case -1: {
                    this.t.kind = Scanner.eofSym;
                    break loop;
                } // NextCh already done
                case 0: {
                    if (recKind != Scanner.noSym) {
                        this.tlen = recEnd - this.t.pos;
                        this.SetScannerBehindT();
                    }
                    this.t.kind = recKind;
                    break loop;
                } // NextCh already done
-->scan3
            }
        }
        this.t.val = this.tval;
        return this.t;
    };
    Scanner.prototype.SetScannerBehindT = function () {
        this.buffer.setPos(this.t.pos);
        this.NextCh();
        this.line = this.t.line;
        this.col = this.t.col;
        this.charPos = this.t.charPos;
        for (var i = 0; i < this.tlen; i++)
            this.NextCh();
    };
    // get the next token (possibly a token already seen during peeking)
    Scanner.prototype.Scan = function () {
        if (this.tokens.next == null) {
            return this.NextToken();
        }
        else {
            this.pt = this.tokens = this.tokens.next;
            return this.tokens;
        }
    };
    // peek for the next token, ignore pragmas
    Scanner.prototype.Peek = function () {
        do {
            if (this.pt.next == null) {
                this.pt.next = this.NextToken();
            }
            this.pt = this.pt.next;
        } while (this.pt.kind > Scanner.maxT); // skip pragmas
        return this.pt;
    };
    // make sure that peeking starts at the current scan position
    Scanner.prototype.ResetPeek = function () { this.pt = this.tokens; };
    return Scanner;
}()); // end Scanner
CocoRJS.Scanner = Scanner;
/*
let scanner : Scanner  = new Scanner(`let a : string = "str";`, "test.txt");
let tok : Token = scanner.Scan()
while(tok.kind != Scanner.eofSym)
{
    console.log(tok);
    tok = scanner.Scan();
}
*/
})(CocoRJS || (CocoRJS = {}));
