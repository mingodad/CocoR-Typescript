/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/
-->begin

-->namespace //For Javascript we do not emmit any namespace and use a fixed one
var CocoRJS;
(function (CocoRJS) {
Object.assign(this, CocoRJS); //concatenate then

var Parser = /** @class */ (function () {

-->constants

    Parser.minErrDist = 2;

-->declarations

    function Parser(scanner) {
        this.errDist = Parser.minErrDist;
        this.scanner = scanner;
        this.errors = new Errors(this.scanner.parseFileName);
        this.log = console.log;
-->constructor
    }

    Parser.prototype.SynErr = function (n) {
        if (this.errDist >= Parser.minErrDist)
            this.errors.SynErr(this.la.line, this.la.col, n);
        this.errDist = 0;
    };
    Parser.prototype.SemErr = function (msg) {
        if (this.errDist >= Parser.minErrDist)
            this.errors.SemErrLineColStr(this.t.line, this.t.col, msg);
        this.errDist = 0;
    };
    Parser.prototype.Get = function () {
        for (;;) {
            //this.log(this.t, this.la);
            this.t = this.la;
            this.la = this.scanner.Scan();
            if (this.la.kind <= Parser.maxT) {
                ++this.errDist;
                break;
            }
-->pragmas
            this.la = this.t;
        }
    };
    Parser.prototype.isKind = function (t, n) {
        var k = t.kind;
        while (k >= 0) {
            if (k == n)
                return true;
            k = Parser.tBase[k];
        }
        return false;
    };
    Parser.prototype.Expect = function (n) {
        if (this.isKind(this.la, n))
            this.Get();
        else {
            this.SynErr(n);
        }
    };
    Parser.prototype.StartOf = function (s) {
        return Parser.set[s][this.la.kind];
    };
    Parser.prototype.ExpectWeak = function (n, follow) {
        if (this.isKind(this.la, n))
            this.Get();
        else {
            this.SynErr(n);
            while (!this.StartOf(follow))
                this.Get();
        }
    };
    Parser.prototype.WeakSeparator = function (n, syFol, repFol) {
        var kind = this.la.kind;
        if (this.isKind(this.la, n)) {
            this.Get();
            return true;
        }
        else if (this.StartOf(repFol)) {
            return false;
        }
        else {
            this.SynErr(n);
            while (!(Parser.set[syFol][kind] || Parser.set[repFol][kind] || Parser.set[0][kind])) {
                this.Get();
                kind = this.la.kind;
            }
            return this.StartOf(syFol);
        }
    };
    Parser.prototype.SkipNested = function (leftKind, rightKind) {
        // manage nested braces
        if (this.la.kind != rightKind) {
            for (var nested = 1; nested > 0;) {
                //print("==", this.la.line, nested, this.la.kind, this.la.val);
                if (this.la.kind == leftKind)
                    ++nested;
                this.Get();
                if (this.la.kind == rightKind)
                    --nested;
                else if (this.la.kind == Parser._EOF)
                    break;
            }
        }
    };
    Parser.prototype.SkipTill = function (endKind) {
        while (this.la.kind != endKind || this.la.kind != Parser._EOF) {
            this.Get();
        }
    };
    Parser.prototype.SkipTillEOL = function () {
        var currLine = this.la.line;
        while (this.la.line == currLine || this.la.kind != Parser._EOF) {
            this.Get();
        }
    };

-->productions

    Parser.prototype.Parse = function () {
        this.la = new Token();
        this.la.val = "";
        this.Get();
-->parseRoot
    };
    // a token's base type
    Parser.tBase = [
-->tbase
    ];
    Parser.set = [
-->initialization    ];
    return Parser;
}()); // end Parser
CocoRJS.Parser = Parser;
var Errors = /** @class */ (function () {
    function Errors(fileName) {
        this.log = console.log;
        this.count = 0; // number of errors detected
        //public  errorStream : StreamWriter; //.IO.TextWriter = Console.Out;   // error messages go to this stream
        //public  errMsgFormat : string = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
        this.errMsgFormat = "%s:%d:%d %s %s"; // 0=line, 1=column, 2=text
        this.fileName = "grammar"; // 0=line, 1=column, 2=text
        this.fileName = fileName;
    }
    Errors.prototype.SynErr = function (line, col, n) {
        var s;
        switch (n) {
-->errors
            default:
                s = "error " + n;
                break;
        }
        //errorStream.WriteLine(errMsgFormat, line, col, s);
        this.log(this.fileName + ":" + line + ":" + col + " SynErr " + s);
        ++this.count;
    };
    Errors.prototype.SemErrLineColStr = function (line, col, s) {
        //this.errorStream.WriteLine(this.errMsgFormat, line, col, s);
        this.log(this.fileName + ":" + line + ":" + col + " SemErr " + s);
        ++this.count;
    };
    Errors.prototype.SemErr = function (s) {
        //this.errorStream.WriteLine(s);
        this.log(s);
        ++this.count;
    };
    Errors.prototype.Warning = function (line, col, s) {
        //this.errorStream.WriteLine(this.errMsgFormat, line, col, s);
        this.log(this.fileName + ":" + line + ":" + col + " Warning " + s);
    };
    Errors.prototype.WarningStr = function (s) {
        //this.errorStream.WriteLine(s);
        this.log(s);
    };
    return Errors;
}()); // Errors
CocoRJS.Errors = Errors;
var FatalError /*extends Exception*/ = /** @class */ (function () {
    function FatalError(m) {
        throw (m);
    }
    return FatalError;
}());
CocoRJS.FatalError = FatalError;
var Symboltable = /** @class */ (function () {
    function Symboltable(name, ignoreCase, strict) {
        this.scopes = null;
        this.name = name;
        this.ignoreCase = ignoreCase;
        this.strict = strict;
        this.predefined = {};
    }
    Symboltable.prototype.Add = function (t) {
        if (this.scopes != null && this.scopes.length > 0) {
            var ht = this.scopes[this.scopes.length - 1];
            if (!ht.hasOwnProperty(t.val)) {
                ht[t.val] = true;
                return true;
            }
        }
        else if (!this.predefined.hasOwnProperty(t.val)) {
            this.predefined[t.val] = true;
            return true;
        }
        return false;
    };
    Symboltable.prototype.Use = function (t) {
        if (this.scopes != null) {
            for (var i = this.scopes.length - 1; i >= 0; --i) {
                if (this.scopes[i].hasOwnProperty(t.val)) {
                    return true;
                }
            }
        }
        return this.predefined.hasOwnProperty(t.val);
    };
    Symboltable.prototype.pushNewScope = function () {
        if (this.scopes == null)
            this.scopes = [];
        this.scopes.push({});
    };
    Symboltable.prototype.popScope = function () {
        this.scopes.pop();
    };
    return Symboltable;
}());
CocoRJS.Symboltable = Symboltable;
})(CocoRJS || (CocoRJS = {}));